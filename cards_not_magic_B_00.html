<!doctype html>
<html>
<head>

	<meta charset="UTF-8">

<!-- import TweenMax and jquery -->

<!-- 
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://s0.2mdn.net/ads/studio/cached_libs/tweenmax_1.19.1_92cf05aba6ca4ea5cbc62b5a7cb924e3_min.js"></script> -->

<script src="libs/jquery-2.1.0.js"></script>
<script src="libs/TweenMax.min.js"></script>
<script type="text/javascript" src="data/cards.json"></script>
<script src="libs/howler.min.js"></script>


<style>
html, body {
	width: 100%;
	height: 100%;
	margin: 0;
}
body {
	background-image: url('images/bg-texture-stone.jpg');
	
	/*background-image: url('images/white-marble-wallpaper-19.jpg');*/
}
#game-container {
	/*border: 1px dashed orange;*/
	position: relative;
	width: 100%;
	height: 100%;
	/*perspective-origin: 75% 25%;*/
	transform-origin: 200px 100px;
	transform-style: preserve-3d;
	perspective: 1000px;
	/*transform: scale( 0.85 );*/
	top: 50px;
}
#player-card-deck {
	position: absolute;
	left: 420px;
	top: 360px;
	background: rgba(255, 255, 255, 0.5);
	border: 2px solid black;
	box-sizing: border-box;
	perspective: 1000px;
	transform-origin: top left;
	z-index: 100;
	/*transform: scale( 0.85 );*/
}
.game-element {
	position: absolute;
	box-sizing: border-box;
}
.player-element {
	position: absolute;
	border: 2px solid brown;
}
.player-element .portrait {
	display: block;
	width: 110px;
	height: 110px;
}
.player-element-field, .player-hp-field, .player-field {
	position: absolute;
	/*display: block;*/
	box-sizing: border-box;
	font-size: 1em;
	color: white;
	font-family: serif;
	border: 1px solid brown;
	background: rgba(0,0,0,0.4);
	text-align: center;
	padding: 0.2em 0.3em;
}
.player-field {
	white-space: nowrap;
	}
.player-hp-field {
	font-family: sans-serif;
	font-weight: bold;
}

/* 
 -----------------------------
	
	CARD

 -----------------------------
*/
.card {
	font-family: sans-serif;
	font-size: 10px;
	color: #333;
	/*box-shadow: 5px 5px 6px rgba(0,0,0,0.5);*/
	/*transform: perspective( 200px );*/
	transform-style: preserve-3d;

}
.card, .card-front, .card-back, .card-shadow, .card-hilite, .card-dim, .card-slot,.card-slot:before {
	position: absolute;
/*	width: 100px;
	height: 147px;*/
	border-radius: 1em;
	box-sizing: border-box;
}
.card-hilite {
	box-shadow: 0px 0px 12px 6px rgba(255,255,0,0.6);
}
.card-dim { 
	background-color: rgba(128,128,128,0.5);
	visibility: visible;
	/*border: 2px solid grey;*/
	/*z-index: 1000;*/
	/*backface-visibility: visible;*/
	visibility: visible;
	width: 100%;
	height: 100%;
	transform: rotateY( 180deg );
 }
.card-front, .card-back {
	-webkit-backface-visibility: hidden;
	-moz-backface-visibility: hidden;
	backface-visibility: hidden;
	/*border: 2px solid grey;*/
	
	padding: 0.5em;
}
.card-front {
	background-color: #fdf2e2;
	/*background-image: url('images/bg-texture-light-300x300.jpg');*/
	background-image: url('images/white-marble-wallpaper-19.jpg');
	background-size: cover;
	transform: rotateY( 180deg );
}
.card-back {
	background-color: brown;
	background-image: url('images/megaDoug_logo_hollow_rainbow.png'), url('images/bg-texture-300x300.jpg');
	background-position: center 45%, center;
	background-repeat: no-repeat, no-repeat;
	background-size: 90% auto, cover;
	/* z-index: 2; */
	/*transform: rotateY( 0deg );*/
	/*background-size: contain;*/
	/*border: 1px solid black;*/
}
.card span {
	margin-right: .2em;
	border-radius: 1em;
}
/*.card .cost {
	font-weight: 900;
	background-color: white;
	padding: .1em;
	border: 1px solid #b89f94;
	text-align: center;
	display: inline-block;
}*/
.card .title {
	font-weight: 900;
	font-family: serif;
	font-size: 1.2em;
	color: #6d5246;
	text-shadow: 1px 1px 0.1em white;
}
.card .title:after {
	white-space: pre;
	content:'\A';
}
.card .illustration-creature, .card .illustration-spell {
	border: 2px solid #b89f94;
	border-color: #b89f94 #d4c2ba #dacac3 #c4aba1;
	width: 100%;
	height: auto;
	box-sizing: border-box;
}
.card .illustration-spell {
	border-radius: 50%;
}
.card .attributes {
	text-align: right;
}
.card .attributes span {
	font-weight: bold;
	background-color: white;
	padding: .1em .2em;
	border: 1px solid black;
	text-align: center;
	display: inline-block;
	vertical-align: middle;
}
.card .attributes .attack {
	background-color: #ff8a8a;
}
.card .attributes .defense {
	background-color: #8abbff;
}
.card .attributes .cost {
	background-color: #ffe647;
}
.card .attributes .hp {
	background-color: #8aff9b;
}
.card-shadow {
	box-shadow: 0px 0px 10px 4px rgba(0,0,0,0.5);
	transform-style: preserve-3d;
	/*margin: 10px 0 0 10px;*/
	background-color: rgba(0,0,0,0.5);
}

/* 
 -----------------------------
	
	CARD RACK

 -----------------------------
*/
.card-slot {
	position: absolute;
	background-color: rgba( 128, 128, 255, 0.5 );
	border: 1px solid #DDD;
	box-shadow: inset 0 0 1em rgba(0,0,0,0.5);
	box-sizing: border-box;
}
.card-slot::before {
	content: "";
	position: absolute;
	border: 2px solid #DDD;
	border-top-color: #888;
	border-left-color: #aaa;
	border-right-color: #CCC;
	box-sizing: content-box;
	top: 0;
	bottom: 0;
	left: 0;
	right: 0;
}
.card-rack {
	/*border: 1px solid black;*/
	/*background-color: rgba( 64, 64, 64, 0.65 ); */
	/*box-shadow: inset 0 0 40px cornflowerblue;*/
}

#bg {
	position: absolute;
	width: 100%;
	height: 100%;
	background-color: rgba(0,0,0, 0.5);
}
#layout {
	position: absolute;
	display: block;
	background: url( "images/gameplay_spectromancer.jpg" );
	background-repeat: no-repeat;
	background-size: contain;
	width: 900px;
	height: 100%;
	/*border: 2px dashed yellow;*/
	
}
#ai-cards {
	position: absolute;
	top: 500px;
	left: 10px;
	padding: 15px;
	box-sizing: border-box;
	border: 1px solid white;
	box-shadow: inset 0 0 20px black;
	transform-origin: top left;
	transform: scale(0.6);
}

/* 
 -----------------------------
	
	GUI

 -----------------------------
*/
.floating-field {
	color: black;
	text-shadow: 0 0 0.1em white;
	font-family: sans-serif;
	font-size: 1.1em;
	/*font-weight: bold;*/
	border-radius: 50%;
	/*background-color: rgba(255,255,0,0.5);*/
	/*border: 1px solid yellow;*/
	/*padding: 1em;*/
	width: 2em;
	height: 2em;
	padding-top: 0.4em;
	margin-left: -1em;
	margin-top: -1em;
	text-align: center;
}
/*.floating-field:after {
	content: "";
	border-top: 1px solid yellow;
	border-left: 1px solid yellow;
	position: absolute;
	top: 50%;
	left: 50%;
	height: 100%;
	width: 100%;
}*/
.floating-field.red {
	color: #FFF000;
	text-shadow: 0 0 0.1em black, 0 0 1px black, 0px 2px 0.1em black, 0px -2px 1px black, -2px 0px 1px black, 2px 0px 1px black;
	background-color: rgba(255,0,0,0.65);
}
.floating-field.green {
	color: white;
	text-shadow: 0 0 0.1em darkgreen, 0 0 1px darkgreen, 0px 2px 0.1em darkgreen, 0px -2px 1px darkgreen, -2px 0px 1px darkgreen, 2px 0px 1px darkgreen;
	background-color: rgba(0,255,0,0.65);
}
.points-field { 
	position: absolute;
	font-family: sans-serif;
	font-weight: bold;
	font-size: 1em;
	width: 4em;
	margin-right: -2em;
	margin-top: -0.5em;
}
.points-field.positive {
	color: green;
	text-shadow:
	   -1px -1px 0 #FFF,  
	    1px -1px 0 #FFF,
	    -1px 1px 0 #FFF,
	     1px 1px 0 #FFF;
}
.points-field.negative {
	color: red;
	text-shadow:
	   -1px -1px 0 #000,  
	    1px -1px 0 #000,
	    -1px 1px 0 #000,
	     1px 1px 0 #000;
}

.turn-counter, #skip-turn-button {
	position: absolute;
	left: 300px;
	top: 520px;
	width: 60px;
	height: 60px;
	border: 1px solid brown;
	box-shadow: 0 0 10px black;
	box-sizing: border-box;
	padding: 0.5em;
	font-size: 1em;
	color: black;
	font-family: sans-serif;
	text-align: center;
}

#skip-turn-button {
	border-radius: 50%;
	
	top: 590px;
	background-color: rgba( 255, 255, 255, 0.3 );
	box-shadow: inset 0 -0.5em 0.5em -0.25em black, 0 3px 10px black;
}

#card-description {
	position: absolute;
	/* */
	box-shadow: inset 0.3em 0.2em 0.15em #222, inset -0.5em -0.5em 0.5em #222, inset -0.5em -0.5em 0.5em rgba(200,200,255,0.95), inset 0.4em 0.4em 0.35em rgba(200,200,255,0.95), inset 0.5em 0.5em .5em 0.5em #222;
	padding: 1em;
	border-radius: 0.5em;
	box-sizing: border-box;
	border-color: white;
	color: gold;
	text-shadow: 0.15em 0.3em 0.3em #221111;
	top: 360px;
	left: 10px;
	width: 400px;
	height: 140px;
}
#card-description-content {
	height: 140px;
}
#game-logo {
	position: absolute;
	height: 100px;
	width: auto;
	left: 10px; /*50%;*/
	/*transform: translateX(-50%);*/
	top: 175px;
}
#splash-screen {
	position: absolute;
	width: 100%;
	height: 100%;
	margin: 0;
	box-sizing: border-box;
	background-color: white;
	z-index: 1000;
}
#splash-screen #content {
	/*position: absolute;*/
	display: inline-block;
	position: absolute;
	text-align: center;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	border: 2px solid orange;
	padding: 2em;
}

</style>

</head>
<body>
<!-- <span style="font-family: sans-serif; font-size: 0.5em; color: #555;" >Tested in webkit</span> -->
<!-- <img id="layout" src="images/gameplay_spectromancer.jpg" /> -->
<!-- <div id="layout"></div> -->
<!-- <div id="bg"></div> -->
<img id="game-logo" src="images/game-logo.png" />
<div id="ai-cards"></div>
<div id="card-description"></div>

<div id = "splash-screen">
	<div id = "content" >OFFICE BATTLE
		<br />
		<button id="start-button">start</button>
	</div>
</div>

<!-- <audio id="attack-sound" src="sounds/scrape.wav" autoplay="false" ></audio> -->
<!-- <audio id="spell-sound" src="sounds/spell.wav" autoplay="false" ></audio> -->
<!-- <audio id="spell-sound">
	<source src="sounds/spell.wav" type="audio/wav" >
</audio> -->
<!-- <audio id="special-sound" src="sounds/special.wav" autoplay="false" ></audio> -->
<audio id="flip-sound" src="sounds/card-flip.wav" autoplay="false" ></audio>


<!-- Currently, card deck is only generated once, as part of the process of creating a player (either Human or AI).  Need to allow for changing cards in a deck.

Deck.changeCards() ? -->





<script>
let GameScope = (function(namespace){
	// Isolated namespace for all this code...

	// let Game;



	let isTouch = ("touchstart" in document.documentElement);
	let cardWidth = 94,
		cardHeight = 126,
		gameContainer = document.createElement("div");
	gameContainer.id = "game-container";
	document.body.appendChild(gameContainer);

	let playerCardGrid = document.createElement("div");
	playerCardGrid.id = "player-card-deck";
	$(playerCardGrid).css({width: cardWidth*4 +30, height: cardHeight*4 +30, padding: 15});
	gameContainer.appendChild( playerCardGrid );

	let AICardGrid = document.getElementById("ai-cards");
	$(AICardGrid).css({width: cardWidth*4 +30, height: cardHeight*4 +30});
	$(AICardGrid).detach();
	gameContainer.appendChild(AICardGrid);

	let turnCountField = document.createElement("span");
	$(turnCountField).addClass("turn-counter");
	gameContainer.appendChild(turnCountField);

	let skipTurnButton = document.createElement("button");
	$(skipTurnButton).attr("id",  "skip-turn-button");
	$(skipTurnButton).html("skip<br />turn");
	gameContainer.appendChild(skipTurnButton);
	// $(skipTurnButton).css("display","none");
	

	let computerPlayer, livePlayer;

	let cardDescriptionField = document.getElementById("card-description");
	let cardDescriptionContent = document.createElement ("div");
	cardDescriptionContent.id = "card-description-content";
	cardDescriptionField.appendChild(cardDescriptionContent);
	$(cardDescriptionField).detach();
	gameContainer.appendChild(cardDescriptionField);




	//===========================================
	//
	//				SOUNDS
	//
	//===========================================

	let Sounds = {};
	Sounds.initSounds = function () {
		console.log("initSounds()");
		// Sounds.attack = document.getElementById("attack-sound");
		// Sounds.spell = document.getElementById("spell-sound");
		// Sounds.special = document.getElementById("special-sound");
		// Sounds.flip = document.getElementById("flip-sound");
		Sounds.attack = new Howl({
		  src: ['sounds/scrape.wav']
		});
		Sounds.spell = new Howl({
			src: ['sounds/spell.wav']
		});
		Sounds.special = new Howl({
			src: ['sounds/special.wav']
		});
		Sounds.flip = new Howl({
			src: ['sounds/card-flip.wav']
		});
	}

	let startButton = document.getElementById("start-button");
	startButton.addEventListener("click", function(e) {
		// Sounds.special.play();
		// Sounds.spell.src = "sounds/spell.wav";
		Sounds.spell.play();
		// document.getElementById("spell-sound").play();
		document.getElementById("splash-screen").style.display = "none";
		Game.startGame();
	});






/*

 ######  ##          ###     ######   ######  ########  ######  
##    ## ##         ## ##   ##    ## ##    ## ##       ##    ## 
##       ##        ##   ##  ##       ##       ##       ##       
##       ##       ##     ##  ######   ######  ######    ######  
##       ##       #########       ##       ## ##             ## 
##    ## ##       ##     ## ##    ## ##    ## ##       ##    ## 
 ######  ######## ##     ##  ######   ######  ########  ######  

*/

	/////////////////////////////////////////////////////
	//
	//	GAME ELEMENT CLASS -- Not sure we need this
	//
	/////////////////////////////////////////////////////
	/* 
	*  GameElement is basic model for a 'physical' game piece - eg. Card, slot, etc
	*  Not to be confused with the Game object, which is not to be confused with the Game namespace
	*/

	class GameElement {
		constructor ( el ) {
			// console.log('GameElement constructor()');
			this._x = 0;
			this._y = 0;
			this._myEl = el;
			this._height = $(el).outerHeight();
			this._width = $(el).outerWidth();
			$(this._myEl).addClass("game-element");
		}
		animateTo( x, y ) {
			if ( typeof x === "number" && typeof y === "number" ) {
				this._y = y;
				this._x = x;
				let dur = 1;
				TweenMax.to( this._myEl, dur, {css:{left: this._x, top: this._y}, delay: 0, ease:Power2.easeIn});
			}
		}
		kill () {
			$(this.el).remove();
			delete this;
		}
		// getters & setters
		set x ( value ) {
		 	if ( value != undefined ) {
		 		this._x = value;
				$(this._myEl).css("left",value);
	 			// TweenMax.set( this._myEl, {x:value});
		 	}
		 }
		get x () {
			// console.log("GameElement.get x");
			return this._x;
		}
		set y ( value ) {
		 	if ( value != undefined ) {
		 		this._y = value;
				$(this._myEl).css("top",value);
		 		// TweenMax.set( this._myEl, {y:value});	
		 	} 
		 }
		get y () {
			return this._y;
		}
		get el () {
			return this._myEl;
		}
		set height ( value ) {
			if ( value != undefined ) {
				TweenMax.set( this._myEl, {height:value});
				this._height = value;
			}
		}
		get height () {
			return $(this.el).outerHeight();
		}
		set width ( value ) {
			if ( value != undefined ) {
				TweenMax.set( this._myEl, {width:value});
				this._width = value;
			}
		}
		get width () {
			return $(this.el).outerWidth();
		}
	}







/*

 .o88b.  .d8b.  d8888b. d8888b. 
d8P  Y8 d8' `8b 88  `8D 88  `8D 
8P      88ooo88 88oobY' 88   88 
8b      88~~~88 88`8b   88   88 
Y8b  d8 88   88 88 `88. 88  .8D 
 `Y88P' YP   YP 88   YD Y8888D' 
                                
*/                                

/*
	Card.special.misc is a catch-all object 
	for holding properties used for future 
	inspections of card actions/abilities.
	These include:

	{ wall : bool } 
	 - is this card of type wall?
	{ "spellDamageModifier" : "*:1.5"} 
	 - amount by which to multiply or add a spell's damage.  Note indicator with colon.
	{ spawn : { type : creatureName } { number : 2 } { location : "neighbors" } { event : "summon" } }


*/



	///////////////////////////////////////////
	//
	//		CARD CLASS
	//
	///////////////////////////////////////////

	class Card extends GameElement {

		/*
		Handle non-attack effects for each card
		...
		Damage host 
		Damage enemy
		Heal host
		Increase host element power
		Decrease host element power
		Decrease enemy element power
		Effects at start or end of owner's turn,
		Effects at start or end of enemy's turn
		Effects on summon
		Effects on "die"
		Also, cards should have (effects at end of owner's turn):

		Owner Element modifiers: [w,x,y,z]
		Opponent Element modifiers: [w,x,y,z]
		Owner HP modifier: x
		Opponent HP mofifier: x
		Self (creature) HP modifier: x
		Neighbors (creatures) HP modifiers: [x,y]
		Siblings (creatures) HP modifier: x

		For Spells:

		// Does the spell operate automatically?

			// on the Active player?

			// and/or on the Passive player?

			// and/or on Active player card?

			// and/or on Passive player card?

		// Or does spell require clicking on a target card?

			// Owner's card?

			// Opponent's card?
		*/

		constructor ( ele, atk, def, hp, cost, img, tit, type, specials, description, misc ) {
			// console.log('Card constructor('+ele+', '+atk+', '+def+', '+cost+', '+img+', '+tit+', '+hp+')');
			let _el = document.createElement("div");
			super( _el );
			this.init(atk, def, cost, img, tit, ele, hp, type, specials, description, misc );
		}

		init ( atk, def, cost, img, tit, ele, hp, type, specials, description, misc ) {
			this._type = type; // "creature" or "spell"
			this._faceShowing = -1;
			this._attack = atk != undefined ? atk : 0;
			this._defense = def != undefined ? def : 0;
			this._cost = cost != undefined ? cost : 0;
			this._level = this._attack + this._defense + this._cost;
			this._imgSrc = img != undefined ? img : "";
			this._title = tit != undefined ? ""+tit : "...";	
			this._specials = specials;
			for ( let special of this._specials ) {
				// give specials reference to their card
				special.card = this;
			}
			this._description = description;
			this._misc = misc;
			this._shadowEl = document.createElement("div");
			this._hp = this._maxhp = hp;
			this._locked = false;
			this.assemble();
			this.attack = atk;
			this.defense = def;
			this.cost = cost;
			this.elementIndex = ele;
			this._slot = null;
			this._turnPlayed = Game.turnNum;
			// HACK !!!
			if ( this.title === "Fire Drake" ) {
				this._turnPlayed--;
			}
			this._owner = null;
			// 
			let evt = isTouch ? 'touchend' : 'click';
			$(this.el).on( evt, () => {
				this.select() 
			} );
			$(this.el).hover( () => {
				this.rollover();
			}
			);
		}

		assemble () {
			// Assemble Me
			// console.log("Card.assemble()");
			$(this.el).addClass("card");
			// Front
			this._front = document.createElement("div");
			this._front.className = "card-front";
			// Back
			this._back = document.createElement("div");
			this._back.className = "card-back";
			// Title
			this._titleEl = document.createElement("span");
			this._titleEl.className = "title";
			// Level
			// this._lvlEl = document.createElement("span");
			// this._lvlEl.className = "level";
			// Attributes
			this._attributesEl = document.createElement("div");
			this._attributesEl.className = "attributes";
			// Attack
			this._atkEl = document.createElement("span");
			this._atkEl.className = "attack";
			// Defense
			this._defEl = document.createElement("span");
			this._defEl.className = "defense";
			// Cost
			this._costEl = document.createElement("span");
			this._costEl.className = "cost";
			// HP
			this._hpEl = document.createElement("span");
			this._hpEl.className = "hp";
			// Image
			this._imgEl = document.createElement("img");
			this._imgEl.className = "illustration-"+this._type;
			// Shadow
			this._shadowEl.className = "card-shadow";
			// Dim cover
			this._dimEl = document.createElement("div");
			this._dimEl.className = "card-dim";
			// 
			this.el.appendChild(this._front);
			this.el.appendChild(this._back);
			this.el.appendChild(this._dimEl);
			// this._front.appendChild(this._lvlEl);
			
			this._front.appendChild(this._titleEl);
			this._front.appendChild(this._imgEl);
			this._front.appendChild(this._attributesEl);
			this._attributesEl.appendChild(this._atkEl);
			this._attributesEl.appendChild(this._defEl);
			this._attributesEl.appendChild(this._costEl);
			this._attributesEl.appendChild(this._hpEl);
			gameContainer.appendChild(this._shadowEl);
			gameContainer.appendChild(this.el);
			TweenMax.set(this._front, { width: cardWidth, height: cardHeight });
			TweenMax.set(this._back, { width: cardWidth, height: cardHeight });
			TweenMax.set(this._shadowEl, { width: cardWidth, height: cardHeight, transform:"translateZ(0px)" });
			TweenMax.set(this.el, { width: cardWidth, height: cardHeight, transform:"translateZ(2px)" });
		}

		changeParent ( el ) {
			if ( el instanceof HTMLElement ) {
				$(this._shadowEl).detach();
				$(el).append($(this._shadowEl));
				
				$(this.el).detach();
				$(el).append($(this.el));
			}
		}
		
		update ( ) {
			// console.log("Card.update()")
		 	this._atkEl.textContent = this._attack;
		 	this._defEl.textContent = this._defense;
		 	this._costEl.textContent = this._cost;
		 	// this._lvlEl.textContent = this._level;
		 	this._titleEl.textContent = this._title;
		 	this._hpEl.textContent = this._hp;
		 	this._imgEl.src = this._imgSrc;
		 }

		 takeDamage ( value ) {
		 	console.log("Card.takeDamage( "+value+" )");
		 	if ( value != undefined ) {
		 		this.hp -= value;
		 	}
		 }

		kill ( simplyRemove ) {
			console.log("Card.kill() ("+this.name+")");
			// simplyRemove = simplyRemove === true;
			// if ( !simplyRemove ) Game.executeDyingCardSpecial ( this );
			$(this._shadowEl).remove();
			if ( this.slot != undefined ) {
				this.slot.card = null;
			}
			
			super.kill();
					
		}

		setSelectBehavior ( func ) {
			console.log("Card.setSelectBehavior( "+this.name+" )");
			this._onSelectFunction = func;
		}
		removeSelectBehavior ( func ){
			console.log("Card.removeSelectBehavior( "+this.name+")");
			this._onSelectFunction = null;
			
			/*
			let evt = isTouch ? 'touchend' : 'click';
			if ( func ) {
				$(this.el).off( evt, func );
			} else {
				$(this.el).off( evt );
			}
			*/
		}
		lock () {
			this._locked = true;
			this.dim();
			this.deselect();
		}
		unlock () {
			this._locked = false;
			this.undim();
		}
		dim () {
			this._dimEl.style.visibility = "visible";
		}
		undim () {
			this._dimEl.style.visibility = "hidden";
		}
		select () {
			console.log("Card.select("+this.name+")");
			if ( !this._locked ) {
				try { this._onSelectFunction() }
				catch (error) { console.log( "ERROR:  "+error ) };
				// this.hilite();
			}
		}
		deselect () {
			if ( this._onDeselectFunction ) {
				this._onDeselectFuntion();
			}
			if ( Game.selectedCard === this ) {
				Game.selectedCard = null;
			}
			this.unhilite();
		}

		rollover () {
			Game.displayCardDescription( this );
		}

		hilite( ) {
			this.el.style.border = "2px solid black";
			this.el.style.boxShadow = " 0px 0px 10px 10px yellow";
		}

		unhilite () {
			this.el.style.border = "none";
			this.el.style.boxShadow = "none";
		}

		flip ( immediate ) { //x, y

			// set up Tween parameters
			if ( document.contains( this.el ) ) {
				let c = this;
				let rotY = c._faceShowing === 1 ? "+=180" : "-=180";
				if ( immediate ) {
					TweenMax.set( c.el, {rotationY: rotY});
				} else {
					// let x2 = x == undefined ? c._x : x;
					// let y2 = y == undefined ? c._y : y;
					// let dx = x2-c._x, dy = y2-c._y;
					// let dist = Math.sqrt( dx*dx + dy*dy );
					// let dur = 0.4 + 0.5 * dist / 700;
					let dur = 0.4;

					// card
					TweenMax.to( c.el, dur, {css:{rotationY: rotY}, delay: 0, ease:Power2.easeIn});
					TweenMax.to( c.el, dur, {css:{z:"+=200"}, yoyo:true, repeat:1, ease:Sine.easeInOut});
					// TweenMax.to( c.el, .75*dur, {css:{x:x2, y:y2}, ease:Power2.easeOut});
					// shadow
					TweenMax.to(c.shadow, dur, {css:{rotationY: rotY}, delay: 0, ease:Power2.easeIn});
					TweenMax.to(c.shadow, dur, {css:{z:"+=200"}, yoyo:true, repeat:1, ease:Sine.easeInOut});
					// TweenMax.to(c.shadow, .75*dur, {css:{x:x2, y:y2}, ease:Power2.easeOut});
				}			
				this._faceShowing *= -1;
			}
		}

		flex ( ) {
			console.log(" START FLEX - "+this.name+", "+this.slot.index);
			let dur = 0.35;
			TweenMax.to( this.el, dur, {z:10, yoyo:true, repeat:1, ease:Sine.easeOut, onComplete: complete});
			let that = this;
			function complete () {
				TweenMax.set(this.target, {z:2});
				console.log(" END FLEX - "+that.name+", "+that.slot.index);
			}
		}

		removeEl () {
			if ( gameContainer.contains( this.el )) {
				gameContainer.removeChild( this.el );
			}
			if ( gameContainer.contains( this._shadowEl )) {
				gameContainer.removeChild( this._shadowEl );	
			}
		}

		// getters + setters 
		get locked () {
			return this._locked;
		}

		set owner ( value ) {
			if ( value instanceof Player ) {
				this._owner = value;
			}
		}
		get owner () {
			return this._owner;
		}

		set slot ( value ) {
			if ( value instanceof Slot ){
				this._slot = value;	
			}
		}
		get slot () {
			return this._slot;
		}

		set attack ( value ) {

			if ( value != undefined ) {
				this._attack = value;
				// this._level = this._attack + this._defense + this._cost;
				this.update();
			} 
		}
		get attack() {
			return this._attack;
		}
						
		set defense ( value ) {
		 	if ( value != undefined ) {
		 		this._defense = value;
		 		// this._level = this._attack + this._defense + this._cost;
		 		this.update();
		 	} 
		 }
		get defense () {
		 	return this._defense;
	 	}
		 				
		set cost ( value ) {
		 	if ( value != undefined ) {
		 		this._cost = value;
		 		// this._level = this._attack + this._defense + this._cost;
		 		this.update();
		 	} 
		 }
		get cost () {
		 		return this._cost;
	 	}

	 	set hp ( value ) {
	 		if ( value != undefined ) {
	 			let oldHP = this._hp;
	 			this._hp = Math.min( value, this._maxhp );
	 			let diff = this._hp - oldHP;
	 			if ( diff != 0 ) {
	 				new FloatingField ( diff, {targetEl:this._hpEl} );
	 			}
	 			this.update();
				if ( this.hp <= 0 ) {
					this._hp = 0;
					Game.executeDyingCardSpecial ( this );
					// Did dying card special bring me back to life?
					if ( this.hp <= 0 ) {
			 			this.kill();
			 		}
		 		}
	 		}
	 	}
	 	get hp () {
	 		return this._hp;
	 	}
		
		get img () {
	 		return this._imgSrc;
	 	}
		
		get title () {
	 		return this._title;
	 	}
	 	get name () {
	 		return this._title;
	 	}
		 
		get shadow () {
			return this._shadowEl;
		}

		set x ( value ) {
			if ( typeof value === "number" ) {
				super.x = value;
				$(this._shadowEl).css("left", value);
				// TweenMax.set( this._shadowEl, {x:value});
			}
		}
		get x () {
			return this._x;
		}
		set y ( value ) {
			if ( typeof value === "number" ) {
				super.y = value;
				$(this._shadowEl).css("top", value);
				// TweenMax.set( this._shadowEl, {y:value});
			}
		}
		get y () {
			return this._y;
		}
		get type () {
			return this._type;
		}
		set type ( value ) {
			if ( value === "creature" || value === "spell" ) {
				this._type = value;
			}
		}

		get turnPlayed () {
			return this._turnPlayed;
		}
		set turnPlayed ( value ) {
			if ( typeof value === "number" ) {
				this._turnPlayed = value;
			}
		}

		get specials () {
			return this._specials;
		}

		get description () {
			return this._description;
		}

		get misc () {
			return this._misc;
		}
	}

	// -- End Card Constructor






/*

########  ##          ###    ##    ## ######## ########      ######  ##          ###     ######   ######  
##     ## ##         ## ##    ##  ##  ##       ##     ##    ##    ## ##         ## ##   ##    ## ##    ## 
##     ## ##        ##   ##    ####   ##       ##     ##    ##       ##        ##   ##  ##       ##       
########  ##       ##     ##    ##    ######   ########     ##       ##       ##     ##  ######   ######  
##        ##       #########    ##    ##       ##   ##      ##       ##       #########       ##       ## 
##        ##       ##     ##    ##    ##       ##    ##     ##    ## ##       ##     ## ##    ## ##    ## 
##        ######## ##     ##    ##    ######## ##     ##     ######  ######## ##     ##  ######   ######  

*/
	



	///////////////////////////////
	//
	//		Player Class
	//
	///////////////////////////////
	/*
		The entity that uses the cards
	*/
	class Player extends GameElement {
		constructor ( name, portraitSrc ) {
			console.log('Player constructor()');
			let _el = document.createElement("div");
			super( _el );
			this._size = 110;
			this._el = _el;
			this._name = name;	
			this.portraitSrc = portraitSrc != undefined ? portraitSrc : "player_default.gif";
			this.init();
			this.assemble();
		}

		init () {
			$(this._myEl).addClass("player-element");
			this._portraitImg = document.createElement("img");
			this._portraitImg.className = "portrait";
			this._portraitImg.src = "images/"+this.portraitSrc;
			this._elementValues = [1,1,1,1];
			this._elementNames = [ "uptime", "downtime", "collaboration", "incentives" ];
			this._hp = 100;
			this._rack = new Rack( this );
			this.deck = new Deck( this );
			// console.log("this.deck: "+this.deck);
			// console.log(this.deck);
			// console.log("this.deck.x: "+this.deck.x);
		}
		assemble () {
			this._el.appendChild(this._portraitImg);
			gameContainer.appendChild(this._el);
			// HP
			let _hp_el = document.createElement("span");
			_hp_el.className = "player-hp-field";
			this._el.appendChild( _hp_el );
			this.hpField = _hp_el;
			this.hp = this._hp;
			// ELEMENTS
			let _elementField0 = document.createElement("span");
			let _elementField1 = document.createElement("span");
			let _elementField2 = document.createElement("span");
			let _elementField3 = document.createElement("span");
			this._elementFields = [_elementField0, _elementField1, _elementField2, _elementField3];
			// position them
			for ( let i = 0; i < this._elementFields.length; i++ ){
				let field = this._elementFields[i];
				field.className = "player-element-field";
				field.innerHTML = this._elementNames[i] + ": <br/>" + this._elementValues[i];
				this._el.appendChild( field );
			}
			// NAME
			this.nameField = document.createElement("span");
			this.nameField.className = "player-field";
			this._el.appendChild( this.nameField );
			this.nameField.textContent = this.name;
		}
		
		takeDamage( value ) {
			console.log("Player.takeDamage( "+value+" )");
			this.hp =  this.hp - value;
		}
		position ( xvalue, yvalue ) {
			this._x = xvalue;
			this._y = yvalue;
		}
		// 
		setElement ( index, value, animate ) {
			console.log("Player.setElement()",animate);
			if ( index != undefined && value != undefined ) {
				animate = animate === true;
				let oldValue = this.getElement( index );
				let diff = value - oldValue;
				if ( animate && diff != 0 ) {
					new FloatingField( diff, {targetEl : this._elementFields[ index ]})	
				}
				this._elementValues[ index ] = value;
				this._elementFields[ index ].innerHTML = this._elementNames[ index ] + ": <br/>" + value;
			}
		}
		getElement ( value ) {
			let index = typeof value === "number" ? value : this._elementNames.indexOf( value );
			if ( index === Number.parseInt( index, 10 ) ) {
				return this._elementValues[ index ];
			}
		}
		subtractFromElement ( index, value, animate ) {
			// console.log("Player.subtractFromElement( "+index+", "+value+")");
			if ( index === Number.parseInt( index, 10 ) && typeof value === "number" ) {
				this.setElement( index, this.getElement( index ) - value, animate );
			}
		}
		addToElement ( index, value, animate ) {
			if ( index === Number.parseInt( index, 10 ) && typeof value === "number" ) {
				this.setElement( index, this.getElement( index ) + value, animate );
			}
		}
		addToElements ( values, animate ) {
			// console.log("Player.addToElements("+values+")");
			if ( Array.isArray( values ) && values.length === this.elementValues.length ) {
				for ( let i = 0; i < values.length; i++ ) {
					this.addToElement( i, values[i], animate );
				}
			}
		}
		get rack () {
			return this._rack;
		}
		// getters & setters
		get name () {
			return this._name;
		}
		set hp ( value ) {
		 	if ( value != undefined ) {
		 		let oldValue = this._hp;
		 		let diff = value - oldValue;
		 		if ( diff != 0 ) {
		 			new FloatingField ( diff, {targetEl:this.hpField} );
		 		}
		 		this._hp = value;
		 		this.hpField.textContent = value;
		 	}
		 }
		get hp () {
			return this._hp;
		}
		get elementValues () {
			return this._elementValues.slice(0);;
		}
		set elementValues ( ar ) {
			if ( Array.isArray( ar ) ) {
				for ( let i = 0; i < this._elementValues.length; i++ ) {
					if ( typeof ar[0] === "number") {
						this.setElement( i, ar[i] );
					}
				}
			}
		}
		get powers () {
			return this._elementValues.slice(0);
		}
		set x( value ) {
			if ( value != undefined ) {
				super.x = value;
				this.rack.x = this._x + 260;
			}
		}
		get x() {
			return this._x;
		}
		
	}





	///////////////////////////////
	//
	// Human Player
	//
	///////////////////////////////
	class HumanPlayer extends Player {
		constructor ( name, portraitSrc ) {
			console.log("HumanPlayer constructor()");
			super( name, portraitSrc );
		}
		init () {
			super.init();
			for ( let i = 0; i < this.rack.slots.length; i++ ) {
				let slot = this.rack.slots[i];
				// Handle Clicking Slots
				let evt = isTouch ? 'touchend' : 'click';
				$(slot.el).on( evt, () => {
					Game.clickSlot( slot );
				})
			};
			// Handle clicking cards
			// Does this belong in Game object?  .startTurn, .humanPhase, .startGame?
			for ( let c = 0; c < this.deck.cards_ar.length; c++ ) {
				let card = this.deck.cards_ar[c];
				card.setSelectBehavior( Game.clickCard );
			}
		}
		assemble(){
			super.assemble();
			for ( let i = 0; i < this._elementFields.length; i++ ){
				let field = this._elementFields[i];
				Game.positionElement( field, 370+ 91*i, this._size - Game.getElementHeight( field ) ) ;
				$(field).css( "width", 88 );
			}
			Game.positionElement(this.hpField, this._size, this._size - Game.getElementHeight( this.hpField ) );
			Game.positionElement(this.nameField, this._size + Game.getElementWidth( this.hpField ) + 8, this._size - Game.getElementHeight( this.nameField ) );
		}
		set y ( value ) {
			if ( value != undefined ) {
				super.y = value;
				this.rack.y = this._y - ( this.rack.height - this.height ) - 50;
			}
		}
		get y () {
			return this._y;
		}
	}





	///////////////////////////////
	//
	// AI Player
	//
	///////////////////////////////
	class AIPlayer extends Player {
		constructor ( name, portraitSrc ) {
			console.log("AIPlayer constructor()");
			super( name, portraitSrc );
			// this.deck.removeEl();
		}
		assemble(){
			super.assemble();
			for ( let i = 0; i < this._elementFields.length; i++ ){
				let field = this._elementFields[i];
				Game.positionElement( field, 370+ 91*i, 0 ) ;
				$(field).css( "width", 88 );
			}
			Game.positionElement(this.hpField, this._size, 0 );
			Game.positionElement(this.nameField, this._size + Game.getElementWidth( this.hpField ) + 8, 0 );
		}
		set y ( value ) {
			if ( value != undefined ) {
				super.y = value;
				this.rack.y = this._y + 50;
			}
		}
		get y () {
			return this._y;
		}
	}




/*

########     ###     ######  ##    ##     ######  ##          ###     ######   ######  
##     ##   ## ##   ##    ## ##   ##     ##    ## ##         ## ##   ##    ## ##    ## 
##     ##  ##   ##  ##       ##  ##      ##       ##        ##   ##  ##       ##       
########  ##     ## ##       #####       ##       ##       ##     ##  ######   ######  
##   ##   ######### ##       ##  ##      ##       ##       #########       ##       ## 
##    ##  ##     ## ##    ## ##   ##     ##    ## ##       ##     ## ##    ## ##    ## 
##     ## ##     ##  ######  ##    ##     ######  ######## ##     ##  ######   ######  

*/




	///////////////////////////////
	//
	// 		RACK (row of cards) CLASS
	//
	///////////////////////////////
	class Rack extends GameElement {
		constructor ( player ) {
			console.log("Rack constructor()");
			let _myEl = document.createElement("div");
			super( _myEl );
			// console.log("rack _x: "+this._x+", _y: "+this._y);
			this._myEl = _myEl;
			$(this._myEl).addClass("card-rack");
			this.init();
			this.assemble();
			this._player = player;
		}

		init () {
			this._numSlots = 6;
			this._slots = [];
			for ( let i = 0; i < this._numSlots; i++ ) {
				let slot = new Slot( this, i );
				this._slots.push( slot );
				this._myEl.appendChild( slot.el );
				slot.x = i * ( cardWidth +4 );
			}
		}

		assemble(){
			gameContainer.appendChild( this._myEl );
			this.width = 6*(cardWidth+4);
			this.height = cardHeight;
		}

		putCardInSlot ( card, slotArg ) {
			// argument [slotArg] is instance of Slot or is an integer
			let slot = slotArg instanceof Slot ? slotArg :  this._slots[ slot ];

			if ( card instanceof Card && slot instanceof Slot ) {
				slot.card = card;
				card.lock();
				card.undim();
				// card.owner = this.player; // Already gets .owner when Deck is dealt
				// card.x = this._x + slot.x;
				// card.y = this._y + slot.y;
				Sounds.flip.play();
			}
		}

		clearSlot ( slotArg ) {
			// argument [slotArg] is instance of Slot or is an integer
			let slot = slotArg instanceof Slot ? slotArg :  this._slots[ slot ];
			slot.clear();
		}

		getEmptySlots () {
			let emptySlots = this._slots.filter( slot => slot.card == undefined );
			return emptySlots;
		}

		get slots () {
			return this._slots;
		}
		get slotAvailable () { 
		// returns booelan
			for ( let s = 0; s < this._slots.length; s ++ ) {
				if ( this._slots[s].card == undefined ) {
					return true;
				}
			}
			return false;
		}
		get player () {
			return this._player;
		}
		get owner () {
			return this._player;
		}
	}




	///////////////////////////////
	//
	// 		Slot (card holder) CLASS
	//
	///////////////////////////////
	class Slot extends GameElement {
		constructor ( rack, index ) {
			let _myEl = document.createElement("div");
			super( _myEl );
			this._myRack = rack;
			this._myEl = _myEl;
			$(this._myEl).addClass("card-slot");
			this._index = index;
			this.init();
			this.assemble();
		}
		init () {
			this._content = null;
		}
		assemble () {
			this.width = cardWidth;
			this.height = cardHeight;
		}
		clear () {
			if ( this.card != null ) {
				// delete the card
				// this.card.kill();
				this.card = null;
			}
		}
		get card () {
			return this._content;
		}
		set card ( card ) {
			if ( card instanceof Card || card == undefined ) {
				this._content = card;
				if ( card instanceof Card ) {
					card.slot = this;	
					// put card element inside this slot
					card.changeParent(this.el);
					card.x = 0;//this.x + this.rack.x;
					card.y = 0;//this.y + this.rack.y;
					// animate card into this slot
					// TweenMax.set(card.el, {z:2});
					card.el.style.zIndex = 60; //10+length*3+a;
					TweenMax.from(card.el, 0.25, {z:"+=100", rotationX: "+=10", ease:Sine.easeIn});
				}
			}
		}
		get index () {
			return this._index;
		}
		get rack () {
			return this._myRack;
		}
	}







/*

########  ########  ######  ##    ##     ######  ##          ###     ######   ######  
##     ## ##       ##    ## ##   ##     ##    ## ##         ## ##   ##    ## ##    ## 
##     ## ##       ##       ##  ##      ##       ##        ##   ##  ##       ##       
##     ## ######   ##       #####       ##       ##       ##     ##  ######   ######  
##     ## ##       ##       ##  ##      ##       ##       #########       ##       ## 
##     ## ##       ##    ## ##   ##     ##    ## ##       ##     ## ##    ## ##    ## 
########  ########  ######  ##    ##     ######  ######## ##     ##  ######   ######  

*/



	///////////////////////////////
	//
	// 		DECK CLASS ( Set of Cards belonging to a player )
	//
	///////////////////////////////
	/*
		Deck is 4x4 - 4 elements, 4 levels (cost) per element
	*/
	class Deck extends GameElement {
		constructor ( player ) {
			console.log("Deck constructor()");
			let _el = document.createElement("div");
			super(_el);
			gameContainer.appendChild(this.el);
			// $(this.el).addClass( "card-deck" );
			this._cards_ar = [];
			this._player = player;
			this.init();
		}

		init () {
			// Build deck of cards
			// col = element-index, row = power (cost-range)
			// TEMP FOR TESTING	v
			let names = ["Minotaur Commander", "Giant Spider","Meditation","Ice Guard", "Nature’s Fury", "Call to Thunder", "Orc Chieftain", "Forest Sprite", "Tornado", "Master Healer", "Water Elemental", "Wall of Lightning", "Armageddon", "Phoenix"]; //"Hydra", "Inferno",
			let musts = [];
			for ( let name of names ) {
				musts.push( Game.makeCardByName( name ) );
			}
			
			for( let col = 0; col < 4; col++ ) {
				for( let row = 0; row < 4; row++ ) {
					// pick a cost from range -> 1-3, 4-6, 7-9, 10-12
					// TEMP FOR TESTING	v FORCE CARDS IN DECK
					let card;
					for ( let must of musts ) {
						if ( col === must.elementIndex && must.cost > (row*3) && must.cost <= (row*3 + 3) ) {
							card = must;
							break;
						}
					} 
					if (card === undefined) {
						let cost = row * 3 + Math.floor( Math.random() * 3 ) + 1;
						card = Game.pickCard( col, cost );
					}
					
					// $(card.el).detach();
					// $(this.el).append(card.el);
					card.changeParent(this.el);
					card.x = col * cardWidth;
					card.y = row * cardHeight;
					this._cards_ar.push(card);
					card.owner = this.player; 
				}
			}
		}

		removeEl () {
			for ( let c = 0; c < this._cards_ar.length; c++ ) {
				this._cards_ar[c].removeEl();
			}
			if ( this.el.parentElement ) {
				this.el.parentElement.removeChild( this.el );
			}
			
		}

		flipCards( immediate ) {
			// Flip Cards
			if ( immediate === true ) {
				for ( let c = 0; c < this._cards_ar.length; c++ ) {
					this._cards_ar[ c ].flip( true );
				}
			} else {
				let cardIndex = 0;
				let dur = 100;
				let flipInterval = setInterval(() => 
					{
						this._cards_ar[ cardIndex ].flip();
						cardIndex ++;
						if ( cardIndex >= this._cards_ar.length ) {
							clearInterval(flipInterval);
						}
					}
					, dur);		
			}
				
		}

		hilite () {
			// console.log("Deck.hilite()");
			for (let c = 0; c < this._cards_ar.length; c++ ) {
				let card = this.cards_ar[c];
				card.hilite();
			}
		} 

		unhilite () {
			for (let c = 0; c < this._cards_ar.length; c++ ) {
				let card = this.cards_ar[c];
				card.unhilite();
			}
		}

		deselect () {
			for ( let c = 0; c < this._cards_ar.length; c++ ){
				this._cards_ar[c].deselect();
			}
		}

		lock () {
			for ( let c = 0; c < this._cards_ar.length; c++ ){
				this._cards_ar[c].lock();
			}
		}
		get player () {
			return this._player;
		}

		get cards_ar () {
			return this._cards_ar;
		}
		set x ( value ) {
			if ( value != undefined && typeof (value) == "number"){
				super.x = value;
				for ( let c = 0; c < this._cards_ar.length; c++ ) {
					let card = this._cards_ar[c];
					card.x = this._x + card.elementIndex * cardWidth;
				}
			}
		}
		get x () {
			return this._x;
		}
		set y ( value ) {
			if ( value != undefined && typeof (value) == "number"){
				super.y = value;
				for ( let c = 0; c < this._cards_ar.length; c++ ) {
					let card = this._cards_ar[c];
					card.y = this._y + Math.floor( card.cost / 3 ) * cardHeight;
				}
			}
		}
		get y () {
			return this._y;
		}
		
	}


		






/*

d88888b db       .d88b.   .d8b.  d888888b d888888b d8b   db  d888b       d88888b d888888b d88888b db      d8888b. 
88'     88      .8P  Y8. d8' `8b `^^88^^'   `88'   888o  88 88' Y8b      88'       `88'   88'     88      88  `8D 
88ooo   88      88    88 88ooo88    88       88    88V8o 88 88           88ooo      88    88ooooo 88      88   88 
88~~~   88      88    88 88~~~88    88       88    88 V8o88 88  ooo      88~~~      88    88~~~~~ 88      88   88 
88      88booo. `8b  d8' 88   88    88      .88.   88  V888 88. ~8~      88        .88.   88.     88booo. 88  .8D 
YP      Y88888P  `Y88P'  YP   YP    YP    Y888888P VP   V8P  Y888P       YP      Y888888P Y88888P Y88888P Y8888D' 
                                                                                                                  
*/                                                                                                                  


	////////////////////////////////////////////
	//
	// 		FLOATING FIELD CLASS ( gui )
	//
	////////////////////////////////////////////
	class FloatingField extends GameElement {

		constructor ( txt, optionsObj ) {
			// console.log("new FloatingField()");
			let _el = document.createElement("span");
			gameContainer.appendChild(_el);
			super( _el );
			
			this.init ( txt, optionsObj );
		}

		init ( txt, optionsObj ) {
			$(this.el).addClass( 'floating-field' );
			this.el.innerHTML = txt;
			if ( !isNaN( txt ) ) {
				let colorClass = Number ( txt ) >= 0 ? "green" : "red";
				$(this.el).addClass( colorClass );
			}
			this.el.style.zIndex = 10000;
			let x = 0, y = 0;
			if ( optionsObj.targetEl != undefined && optionsObj.targetEl instanceof Element ) {
				let point = Game.getElementCenterGlobal ( optionsObj.targetEl );
				x = point.x;
				y = point.y;
			} else if ( optionsObj.point != undefined ){
				x = optionsObj.point.x;
				y = optionsObj.point.y;
			}
			this.x = x;
			this.y = y;
			TweenMax.set( this.el, {css:{z:"+=15"} });
			this.fade( -1 );
		}

		fade ( dir ) {			
			// fade out while drifting up or down
			let dur = 2;
			let ty = this.height * dir;
			TweenMax.to( this.el, dur, {css:{y:"+="+ty}, ease:Sine.easeOut, onComplete: complete});
			TweenMax.to( this.el, dur*0.25, {css:{opacity: 0}, delay: dur*0.75, ease:Sine.easeInOut});
			let that = this;
			function complete() {
				that.kill();
			}
		}
	}










































	/*

	 ######  ########  ######## ##       ##        ######  
	##    ## ##     ## ##       ##       ##       ##    ## 
	##       ##     ## ##       ##       ##       ##       
	 ######  ########  ######   ##       ##        ######  
	      ## ##        ##       ##       ##             ## 
	##    ## ##        ##       ##       ##       ##    ## 
	 ######  ##        ######## ######## ########  ######  
	*/

	// 		SPELLS OBJECT

		let Spells = {};

		Spells.checkCardHasSpellFunction = function ( card ) {
			// console.log("Spells.checkCardHasSpellFunction()");
			for ( let spell of Spells.spellFunctionsTable ) {
				if ( card.name === spell.name ) {
					// console.log("spell",spell);
					// Call Function
					spell.func();
					return true;
				}
			}
			return false;
		}

		Spells.naturesFury = function () {
			console.log("Spells.naturesFury()");
			// Nature's Fury
			let cards = Game.getAllCardsInRack( Game.activePlayer.rack );
			// Create array of caster's creatures' attacks
			let attacks = [];
			for ( let card of cards ) {
				attacks.push( card.attack );
			}
			// Arrange the array highest to lowest
			attacks.sort(function(a, b) {
			  return b - a;
			});
			// Add the first two
			attacks = attacks.slice(0,2);
			let damage = 0;
			for ( let attack of attacks ) {
				damage += attack;
			}
			// Do that damage to opponent
			damage = Game.checkSpecialDefend ( Game.passivePlayer, damage, true );
			Game.passivePlayer.takeDamage(damage);
		}

		Spells.spellFunctionsTable = [

			{ name : "Nature’s Fury", func : Spells.naturesFury }

		];










/*
	 ######      ###    ##     ## ########     #######  ########        ## ########  ######  ######## 
	##    ##    ## ##   ###   ### ##          ##     ## ##     ##       ## ##       ##    ##    ##    
	##         ##   ##  #### #### ##          ##     ## ##     ##       ## ##       ##          ##    
	##   #### ##     ## ## ### ## ######      ##     ## ########        ## ######   ##          ##    
	##    ##  ######### ##     ## ##          ##     ## ##     ## ##    ## ##       ##          ##    
	##    ##  ##     ## ##     ## ##          ##     ## ##     ## ##    ## ##       ##    ##    ##    
	 ######   ##     ## ##     ## ########     #######  ########   ######  ########  ######     ##    
*/






	///////////////
	////////////////////////////
	///////////////////////////////////////////////////////
	//
	//
	//		v GAME object (singleton?) v
	//
	//
	///////////////////////////////////////////////////////
	////////////////////////////
	///////////////

	var Game = {};

	Game.turnNum = 0;
	Game.playerUp = 0; // 0 = human, 1 = AI
	Game.turnPhase = ""; // "start", "playCard", "combat", "end"
	Game.activePlayer = null;
	Game.passivePlayer = null;
	Game.selectedCard = null;
	Game.gameOver = false;
	Game.specialsQueue = [];
	Game.boostQueue = [0,0,0,0];
	// Game.castingCard = null;
	Game.specialWhichNeedsTarget = null;
	Game.targetCard = null;

	Game.initGame = function() {
		console.log("Game.initGame()");
		// Game.createTempCardSet();
		Game.buildSourceDeckFromData( cards_dataObj );
		let topGap = 0;
		// -----------------------------------------------
		// Make Players, Human and AI
		// -----------------------------------------------
		computerPlayer = new AIPlayer( "AI Character", "portrait-AI.jpg" );
		computerPlayer.x = 70;
		computerPlayer.y = topGap;
		computerPlayer.setElement(0, 4);
		computerPlayer.setElement(1, 4);
		computerPlayer.setElement(2, 4);
		computerPlayer.setElement(3, 4);
		computerPlayer.deck.flipCards( true );
		// console.log("computerPlayer.deck: "+computerPlayer.deck);
		// computerPlayer.deck.removeEl();
		// TEMP for visualizing:
		// $(AICardGrid).detach();
		$(computerPlayer.deck.el).detach();
		$(AICardGrid).append($(computerPlayer.deck.el));
		// $(computerPlayer.deck.el).css("top",300);
		// $(computerPlayer.deck.el).css("border", "12px solid orange");

		
		// $(gameContainer).append($(AICardGrid));

		livePlayer = new HumanPlayer( "Player", "portrait-player.jpg" );
		livePlayer.x =  70;
		livePlayer.y = 240+topGap;
		livePlayer.setElement(0, 12);
		livePlayer.setElement(1, 1);
		livePlayer.setElement(2, 3);
		livePlayer.setElement(3, 1);

		// Position Human player's cards
		$(livePlayer.deck.el).detach();
		$(playerCardGrid).append($(livePlayer.deck.el));
		
	}

	Game.startGame = function () {
		console.log("Game.startGame()");
		Game.activePlayer = computerPlayer;
		livePlayer.deck.flipCards();
		// wait is magic number, to wait for all the human player's cards to flip over before unlocking them
		let wait = setTimeout( Game.startTurn, 2500 );
		
	}












/*

d888888b db    db d8888b. d8b   db      d8888b.  .d8b.  d8888b. d888888b .d8888. 
`~~88~~' 88    88 88  `8D 888o  88      88  `8D d8' `8b 88  `8D `~~88~~' 88'  YP 
   88    88    88 88oobY' 88V8o 88      88oodD' 88ooo88 88oobY'    88    `8bo.   
   88    88    88 88`8b   88 V8o88      88~~~   88~~~88 88`8b      88      `Y8b. 
   88    88b  d88 88 `88. 88  V888      88      88   88 88 `88.    88    db   8D 
   YP    ~Y8888P' 88   YD VP   V8P      88      YP   YP 88   YD    YP    `8888Y' 
                                                                                 
*/                                                                                                                                         






	/////////////////////////////////////////////////
	//
	//			GAME TURN PARTS
	//
	/////////////////////////////////////////////////
	Game.startTurn = function () {
		// console.log("Game.startTurn()");
		if ( Game.gameOver ) return;
		Game.turnNum ++;
		console.log("\r\n");
		console.log("------START TURN ("+Game.turnNum+") ---> ------------------------");
		$(turnCountField).html("Turn <br />"+Game.turnNum);
		Game.playerUp = 0;
		Game.startPhase();
	}

	Game.startPhase = function () {
		// console.log("Game.startPhase()");
		console.log("\r\n");
		console.log("-----START PHASE ("+Game.playerUp+")---> -------------------------");
		if ( Game.gameOver ) return;

		Game.turnPhase = "start";
		Game.selectedCard = null;
		Game.activePlayer = Game.playerUp === 0 ? livePlayer : computerPlayer;
		Game.passivePlayer = Game.activePlayer === livePlayer ? computerPlayer : livePlayer;
		Game.arrangeRackDepths();

		// Check all cards for start-phase specials ( owner-turn-start, opponent-turn-start )
		Game.enqueueStartPhaseSpecials();
		// ^ this function Enqueues those specials
		// and sets aside Power boosts
		
		// Add Element points (+1 default)
		Game.updatePlayerElementPoints();

		// Execute the queue
		Game.executeSpecials( function () {
			Game.unlockPlayableCards( Game.activePlayer );
			if ( Game.playerUp === 0 ) {
				Game.startHumanPhase();
			} else if ( Game.playerUp === 1 ) {
				Game.startAIPhase();
			}
		});
		
	}

	Game.boostPowersPhase = function () {

	}

	Game.startHumanPhase = function() {
		console.log("Game.startHumanPhase()");
		// Can Human play a card?
		let cards;
		if ( livePlayer.rack.slotAvailable ) {
			cards = livePlayer.deck.cards_ar.filter( card => !card.locked );
		} else {
			cards = livePlayer.deck.cards_ar.filter( card => !card.locked && card.type == "spell" );
		}
		if ( cards.length === 0 ) {
			Game.showSkipButton();
		}
		// Wait for Human to select card
	}

	Game.startAIPhase = function () {
		console.log("Game.startAIPhase()");
		
		AISelectCard ();		
	}

	Game.endPhase = function () {
		// console.log("Game.endPhase()");
		console.log("\r\n");
		console.log("-----> END PHASE ("+Game.playerUp+")----------------------------");

		if ( Game.gameOver ) return;
		// Handle non-attack effects for each card
		// ...
		// Damage host 
		// Damage enemy
		// Heal host
		// Increase host element power
		// Decrease host element power
		// Decrease enemy element power
		// Game.resolveAttacks();
		Game.turnPhase = "end";
		// Check Cards Specials

		Game.playerUp ++;

		if ( Game.playerUp >= 2 ) {
			Game.endTurn();
		} else {
			Game.startPhase();
		}
		
	}
	// Game.nextPhase = function () {
		
	// 	Game.startPhase();
		
	// }
	Game.endTurn = function () {
		// console.log("Game.endTurn()");
		console.log("\r\n");
		console.log("-----> END TURN ----------------------------");
		console.log("=============================\n\r")

		Game.startTurn();
	}

	Game.endGame = function () {
		console.log("Game.endGame()");
		Game.gameOver = true;
		// Lock both decks
		Game.activePlayer.deck.lock();
		Game.passivePlayer.deck.lock();
		// Announce winner
		let winner, loser;
		if ( livePlayer.hp <= 0 ) {
			winner = computerPlayer;
			loser = livePlayer;
		} else if ( computerPlayer.hp <= 0 ) {
			winner = livePlayer;
			loser = computerPlayer;
		}
		alert ( winner.name+" has defeated "+loser.name+" in "+Game.turnNum+" turns!" );
	}

	Game.checkGameOver = function () {
		if ( livePlayer.hp <= 0 || computerPlayer.hp <= 0 ) {
			Game.endGame();
		}
	}


	Game.skipTurn = function() {
		setTimeout( function() {
			Game.resolveAttacks();
		}, 1000);	
	}


	Game.showSkipButton = function () {
		$(skipTurnButton).css("display","absolute");
	}
	Game.hideSkipButton = function () {
		$(skipTurnButton).css("display","none");
	}

	// When user clicks the button...
	$(skipTurnButton).on( "click", () => {
		
		Game.skipTurn();
		// Game.hideSkipButton();

	} );










/*

d888888b db    db d8888b. d8b   db       .d8b.   .o88b. d888888b d888888b  .d88b.  d8b   db .d8888. 
`~~88~~' 88    88 88  `8D 888o  88      d8' `8b d8P  Y8 `~~88~~'   `88'   .8P  Y8. 888o  88 88'  YP 
   88    88    88 88oobY' 88V8o 88      88ooo88 8P         88       88    88    88 88V8o 88 `8bo.   
   88    88    88 88`8b   88 V8o88      88~~~88 8b         88       88    88    88 88 V8o88   `Y8b. 
   88    88b  d88 88 `88. 88  V888      88   88 Y8b  d8    88      .88.   `8b  d8' 88  V888 db   8D 
   YP    ~Y8888P' 88   YD VP   V8P      YP   YP  `Y88P'    YP    Y888888P  `Y88P'  VP   V8P `8888Y' 
                                                                                                    
*/                                                                                                    




	/////////////////////////////////////////////////
	//
	//			GAME TURN ACTIONS
	//
	/////////////////////////////////////////////////

	Game.queuePowerBoost = function ( boost_ar ) {
		// Player.addToElements( ar );
		for ( let i = 0; i < Game.boostQueue.length; i++ ) {
			Game.boostQueue[i] = Game.boostQueue[i] + boost_ar[i];
		}
	}

	
	Game.chargePlayerForCard = function( card ) {
		// console.log("Game.chargePlayerForCard()");
		Game.activePlayer.subtractFromElement( card.elementIndex, card.cost );
	}
	

	Game.updatePlayerElementPoints = function () {
		// Default +1 to each element
		Game.queuePowerBoost( [1,1,1,1] ); // Default
		console.log("Game.boostQueue: ",Game.boostQueue);
		Game.activePlayer.addToElements( Game.boostQueue );
		Game.boostQueue = [0,0,0,0];	
	}


	Game.selectCard = function( whichCard ) {
		console.log("Game.selectCard()");
		Game.selectedCard = whichCard;
	}


	Game.clickCard = function () {
		console.log("Game.clickCard()");

		// First, deselect all the cards
		livePlayer.deck.deselect();

		// If it's Human Player's turn
		// console.log("Game.activePlayer == livePlayer: "+(Game.activePlayer == livePlayer));
		if ( Game.activePlayer === livePlayer

		// ...and card isn't locked...
		&& !this.locked ){
			
			// If card is type "spell"
			if ( this.type == "spell" ) {
				// Do the spell
				Game.playSpellCard( this );
				this.hilite();
				let that = this;
				setTimeout( function(){
					that.unhilite();
					livePlayer.deck.lock();
				}, 100 );
			} else if ( this.type == "creature" 
				// Else if card is type "creature"
			&& livePlayer.rack.slotAvailable ) {
				// ...and slot is available in Human rack...
				this.hilite();
				// select that card to be placed in next slot clicked
				Game.selectCard( this );
			
			}
		}
	}
	Game.clickSlot = function ( slot ) {
		console.log("Game.clickSlot()");
		/*
			Slot in a rack has been clicked / touched.  Decide what to do with that...
		*/
		// If it's HumanPlayer's turn,
		if ( Game.activePlayer != livePlayer )	return;
		
		// IF HumanPlayer has a card selected,

		if ( Game.selectedCard instanceof Card 
		// And the slot is empty
		&& slot.card == undefined ) {
			// must be creature because it is a selected card ( spells can't be selected )
			Game.playCreatureCard( Game.selectedCard, slot );

			// Deselect original card
			Game.selectedCard.deselect();

			livePlayer.deck.lock();

			// Game.endPhase();
		}
	}
	















	Game.AIPickTargetCard = function () {
		/*
				Pick an unlocked card from the racks and return it.
		*/
		
		// get array of unlocked rack cards
		let allRackCards = Game.getAllCardsInRack( computerPlayer.rack ).concat(Game.getAllCardsInRack( livePlayer.rack ));
		let unlockedCards = allRackCards.filter( card => card.locked === false );

		// Pick one.  
		let index = Math.floor( Math.random()*unlockedCards.length );
		return unlockedCards[ index ];
	}



	
	Game.playSpellCard = function ( card ) {
		console.log("Game.playSpellCard("+card.name+")");
		Game.chargePlayerForCard( card );
		// If spell requires target card...
		if ( Game.specialCheckTargetRequired( card ) ) {
			// console.log("targetRequired?",Game.specialCheckTargetRequired( card ))
			Game.targetCard = null;
			
			// If AI turn, make it pick card...
			if ( Game.activePlayer == computerPlayer ) {
				// Select a target card
				Game.AIPickTargetCard().select();
			}
			
		} else if ( Spells.checkCardHasSpellFunction( card ) ) {
			Game.completePlaySpellCard( card );
		} else {
			Game.completePlaySpellCard( card );
		}
	}


	Game.completePlaySpellCard = function ( card ) {
		console.log("Game.completePlaySpellCard("+card.name+")");
		Game.executeCastPhaseSpecials( card );
		Sounds.spell.play();

		// Is a player defeated?
		Game.checkGameOver();
		if ( !Game.gameOver ) {
			setTimeout( function() {
				Game.resolveAttacks();
			}, 1000);			
		}

	}

	Game.specialCheckTargetRequired = function ( card ) {
		console.log("Game.specialCheckTargetRequired()");
		let specials = Game.getCardSpecialsOfType( card, "cast" );
		for ( let special of specials ) {
			if ( special.target.includes ("target") ) {
				Game.specialWhichNeedsTarget = special;
				switch ( special.target ) {
					case "owner-target-creature":
						Game.makeTargetCardsSelectable( Game.activePlayer.rack );
						break;
					case "opponent-target-creature":
						Game.makeTargetCardsSelectable( Game.passivePlayer.rack );
						break;
					default:
						break;
				}
				return true;
				break;
			}
		}
		return false;
	}

	Game.makeTargetCardsSelectable = function ( rack ) {
		console.log("Game.makeTargetCardsSelectable()");
		// Handle clicking cards
		for ( let  card of Game.getAllCardsInRack( rack ) ) {
			console.log("making ["+card.name+"] selectable");
			card.unlock();
			card.setSelectBehavior( Game.chooseCardForSpell );
			card.hilite();
		}
	}

	Game.chooseCardForSpell = function ( ) {
		console.log("Game.chooseCardForSpell("+this.name+")");
		Game.specialWhichNeedsTarget.targetCard = this;
		 
		for ( let  card of Game.getAllCardsInRack( this.slot.rack ) ) {
			card.removeSelectBehavior();
			card.lock();
			card.undim();
			card.unhilite();
		}

		Game.completePlaySpellCard( Game.specialWhichNeedsTarget.card );
	}


















	Game.playCreatureCard = function ( card, slot ) {
		// console.log("Game.playCreatureCard( "+card.name+")")
		
		Game.chargePlayerForCard( card );

		let dupCard = Game.duplicateCard( card );

		Game.activePlayer.rack.putCardInSlot( dupCard, slot );
		
		// Game.checkSummonCardForSpecial( dupCard );
		setTimeout ( function() {
			Game.enqueueSummonPhaseSpecials( dupCard );
			Game.executeSpecials( function() {
				Game.resolveAttacks();	
			});
		}, 300 );

	}



	Game.resolveAttacks = function() {
		// console.log("Game.resolveAttacks()");
		
		let slotIndexes = [];
		for ( let s = 0; s < Game.activePlayer.rack.slots.length; s++ ) {
			// Check each slot for a card
			let card = Game.activePlayer.rack.slots[s].card;
			// if ( card != undefined) console.log(card.title+" turnPlayed vs turnNum : "+( card.turnPlayed + " vs " +Game.turnNum));
			if ( card != undefined && card.turnPlayed < Game.turnNum && card.attack > 0 ) {
				// Cards by default can't attack on the same turn that they are played
				slotIndexes.push( s );
			}
		}
		if ( slotIndexes.length > 0 ) {
			// If Player has any cards in rack...
			let si = 0;
			let attackWait = setInterval( function() {

				// execute card's attack
				Game.cardAttack( slotIndexes[ si ] );
				
				si++;
				if ( si >= slotIndexes.length || Game.gameOver ) {
					clearInterval( attackWait );
					let wait = setTimeout( Game.endPhase, 1500 );
				}
			}, 1000 );

		} else {
			let wait = setTimeout( Game.endPhase, 1000 );
		}
	}

	Game.cardAttack = function ( slotIndex ) {
		// console.log("Game.cardAttack( "+slotIndex+" )");
		if ( Game.gameOver ) {
			return;
		}
		let card = Game.activePlayer.rack.slots[ slotIndex ].card;
		let defenderCard = Game.passivePlayer.rack.slots[ slotIndex ].card;
		if ( card != undefined ) {
			// Animate card
			let dur = 0.5,
				ty;
			if ( Game.activePlayer === livePlayer ) {
				// Slide up
				ty = -30;
			} else {
				// Slide down
				ty = +30;
			}
			TweenMax.to( card.el, dur, {css:{y:"+="+ty}, yoyo:true, repeat:1, ease:Sine.easeInOut, onRepeat: complete});
			TweenMax.to( card.shadow, dur, {css:{y:"+="+ty}, yoyo:true, repeat:1, ease:Sine.easeInOut});
	
			function complete() {
				
				// Check for attacking card has Special of event:"attack"
				if ( Game.cardHasSpecialOfType( card, "attack" ) ) {
					// Don't do physical attack
					// console.log(card.name+" has special eventtype attack");
				} else {
					if ( defenderCard == undefined ) {
						// no card, attack goes through to passivePlayer
						let damage = Game.checkSpecialDefend ( Game.passivePlayer, card.attack, false );
						Game.passivePlayer.takeDamage( damage );
						// Check for Player "defend" special with target "owner" in Player's cards
					} else {
						// attack defender's card
						let damage = Game.checkSpecialDefend ( defenderCard, card.attack, false );
						defenderCard.takeDamage( damage );
						// Check for "defend" special with target: "self", "neighbor" or "sibling" 
					}	
				}
				Game.executeAttackPhaseSpecials( card );
				// Is a player defeated?
				Game.checkGameOver();
			}
			Sounds.attack.currentTime = 0;
			Sounds.attack.play();
			
		}
	}









/*

db    db d888888b d888888b db      d888888b d888888b d888888b d88888b .d8888. 
88    88 `~~88~~'   `88'   88        `88'   `~~88~~'   `88'   88'     88'  YP 
88    88    88       88    88         88       88       88    88ooooo `8bo.   
88    88    88       88    88         88       88       88    88~~~~~   `Y8b. 
88b  d88    88      .88.   88booo.   .88.      88      .88.   88.     db   8D 
~Y8888P'    YP    Y888888P Y88888P Y888888P    YP    Y888888P Y88888P `8888Y' 
                                                                              
*/                                                                              




	/////////////////////////////////////////////////
	//
	//			GAME UTILITY FUNCTIONS
	//
	/////////////////////////////////////////////////



	Game.displayCardDescription = function ( card ) {
		let name = card == undefined ? "" : "<span style='font-size:1.2em; font-weight:bold; color:orange; line-height: 1.5em;'>"+card.name+"</span><br/>";
		let	txt = card == undefined ? "" : "<span>"+card.description+"</span>";
		let img = card == undefined ? "" : "<img style='float: left; margin-right: 10px;' src='"+card.img+"'' height='100' />";
		
		$(cardDescriptionContent).fadeOut(100, function() {
			cardDescriptionContent.innerHTML = img + name + txt;
			$(cardDescriptionContent).fadeIn(300);
		});
	}

	Game.arrangeRackDepths = function () {
		// Put attacking Player's rack above defender's
		// console.log("Game.arrangeRackDepths()");
		let aSlots = Game.activePlayer.rack.slots;
		let pSlots = Game.passivePlayer.rack.slots;
		let length = aSlots.length;
		for ( let a = 0; a < length; a++ ) {
			if ( pSlots[a].card != undefined ) {
				pSlots[a].card.el.style.zIndex = 10+length+a;
				pSlots[a].card.shadow.style.zIndex = 10+a;
			}
			if ( aSlots[a].card != undefined ) {
				aSlots[a].card.el.style.zIndex = 10+length*3+a;
				aSlots[a].card.shadow.style.zIndex = 10+length*2+a;
			}
		}
		// Game.passivePlayer.rack.el.style.zIndex = "1";
		// Game.activePlayer.rack.el.style.zIndex = "2";
	}

	Game.duplicateCard = function ( card ) {
		// console.log("Game.duplicateCard()");
		// Duplicate that card
		/*
		let dupCard = new Card(
		card.elementIndex,
		card.attack,
		card.defense,
		card.hp,
		card.cost,
		card.img,
		card.title,
		card.type,
		(card.specials),
		card.description,
		cloneObject(card.misc)
		);
		*/
		// Place face up on top of original card
		// dupCard.x = card.x;
		// dupCard.y = card.y;
		let dupCard = Game.makeCardByName( card.name );
		dupCard.owner = card.owner;
		dupCard.flip( true );
		
		return dupCard;
	}

	Game.positionElement = function( el, x, y ) {
		$(el).css({top: y, left: x});
	}
	Game.getElementHeight = function( el ) {
		return $(el).outerHeight();
	}
	Game.getElementWidth = function( el ) {
		return $(el).outerWidth();
	}
	Game.getElementPosition = function( el ) {
		let pos = $(el).position();
		return { x: pos.left, y: pos.top };
	}
	Game.getElementCenterGlobal = function ( el ) {
		// relative to gameContainer
		let gcOffset = $(gameContainer).offset();
		let pos = $(el).offset();
		pos.left += Game.getElementWidth( el )*0.5 - gcOffset.left;
		pos.top += Game.getElementHeight( el )*0.5 - gcOffset.top;
		return { x: pos.left, y: pos.top };
	}


	Game.getAllCardsInRack = function( rack, excludeCard ) {
		let cards = [];
		for ( let s = 0; s < rack.slots.length; s++ ) {
			let card = rack.slots[s].card;
			if ( card instanceof Card && card != excludeCard ) {
				cards.push( card );
			}
		}
		return cards;
	}

	Game.getSiblings = function ( card ) {
		let cards = Game.getAllCardsInRack( card.owner.rack, card );
		return cards;
	}

	Game.getCardNeighbors = function ( card ) {
		// console.log("Game.getCardNeighbors( "+card.name+" )");
		let cards = [];
		// Get card's slot index
		let index = card.slot.index;
		if ( index > 0 ) {
			// Get slot to left
			let leftSlot = card.slot.rack.slots[ index -1 ];
			if ( leftSlot.card != undefined ) {
				cards.push( leftSlot.card );
				// console.log("found card to left");
			}
		}
		if ( index < card.slot.rack.slots.length -1 ) {
			// Check Slot to right
			let rightSlot = card.slot.rack.slots[ index + 1];
			if ( rightSlot.card != undefined ) {
				cards.push( rightSlot.card );
				// console.log("found card to right")
			}
		}
		return cards;
	}

	Game.getCardAcross = function ( card ) {
		let index = card.slot.index;
		let opponent = Game.getOpponent( card.owner );
		return opponent.rack.slots[ index ].card;
	}

	Game.getOpponent = function ( player ) {
		return player === Game.activePlayer ? Game.passivePlayer : Game.activePlayer;
	}

	Game.getNeighborSlots = function ( slot ) {
		let neighborSlots = [];
		let index = slot.index;
		if ( index > 0 ) {
			// Get slot to left
			neighborSlots.push( slot.rack.slots[ index -1 ] );
		}
		if ( index < slot.rack.slots.length -1 ) {
			// Check Slot to right
			neighborSlots.push( slot.rack.slots[ index + 1] );
		}
		return neighborSlots;
	}
	Game.getSiblingSlots = function ( slot ) {
		let slots = [];
		for ( let s = 0; s < slot.rack.slots.length; s++ ) {
			if ( s != slot.index ) {
				slots.push( slot );	
			}
		}
		return slots;
	}

	Game.getEmptySlots = function ( slots ) {
		// return array of empty slots
		for ( let i = slots.length-1; i >= 0; i-- ) {
			if ( slots[i].card != undefined ) {
				slots.splice( i, 1 );
			}
		}
		return slots;
	}


/*	Game.cardFlex = function ( card ) {
		let dur = 0.35;
		let flexTween = TweenMax.to( card.el, dur, {z:50, yoyo:true, repeat:1, ease:Sine.easeOut, onComplete: complete});
		function complete () {
			TweenMax.set(this.target, {z:2});
		}
	}
*/





/*

 d888b   .d8b.  .88b  d88. d88888b      d8888b. d88888b  .o88b. db   dD 
88' Y8b d8' `8b 88'YbdP`88 88'          88  `8D 88'     d8P  Y8 88 ,8P' 
88      88ooo88 88  88  88 88ooooo      88   88 88ooooo 8P      88,8P   
88  ooo 88^^^88 88  88  88 88^^^^’      88   88 88^^^^’ 8b      88`8b   
88. ~8~ 88   88 88  88  88 88.          88  .8D 88.     Y8b  d8 88 `88. 
 Y888P  YP   YP YP  YP  YP Y88888P      Y8888D' Y88888P  `Y88P' YP   YD 
                                                                        
                                                                        
*/                                                                        



	/////////////////////////////////////////////////
	//
	//			BUILD and manage GAME DECK (Master Deck)
	//
	/////////////////////////////////////////////////

	Game.cards_ar = [];

	/*
	{"name" : "fire", "cards" : [
		{ 
		"name" : "Goblin Berserker",
		"element" : "fire",
		"type" : "creature",
		"attack" : 4,
		"life" : 16,
		"cost" : 1,
		"specials" : [
			{
				"event" : "owner-turn-start",
				"target" : "neighbors",
				"effect" : "hp",
				"amount" : -2,
			}]
		}
	*/

	Game.buildSourceDeckFromData = function ( dataObj ) {
		console.log("Game.buildSourceDeckFromData()");
		console.log("dataObj.elements.length: "+dataObj.elements.length);
		for ( let e = 0; e < dataObj.elements.length; e++ ) {
			console.log("element: "+e);
			let element = dataObj.elements[e];
			// if ( e == 4 || e == 0 ) {
			// 	console.log(element);
			// }
			for ( let c = 0; c < element.cards.length; c++ ) {
				let card = element.cards[c];
				let def = card.defense != undefined ? card.defense : 0;
				let img = card.img == undefined ? "images/sample-image.jpg" : "images/"+card.img;
				let misc = card.misc != undefined ? card.misc : {};
				for ( let special of card.specials ) {
					if ( special.misc === undefined ) {
						special.misc = {};
						// ? 
					}
					special.isNonPhysical = special.isNonPhysical === true;
				}
				// TEMP
				// if ( card.type == "spell" ) {
				// 	card.attack = Math.round( card.cost * 1.5 );
				// }
				Game.cards_ar.push( 
					{ type : card.type, 
					elementIndex : e, 
					attack : card.attack, 
					defense : def, 
					cost : card.cost, 
					img : img, 
					name : card.name, 
					hp : card.life,
					specials : card.specials,
					description : card.description,
					misc : misc
					 }
				 );
			}
		}
	}
	// TEMP GENERATE ARTIFICIAL CARD TYPES:
	// ALL CARDS
	/*
	Game.createTempCardSet = function () {
		// All the cards, from which "Decks" are selected, using "Game.pickCard()"
		let names = ["supply", "downtime", "product", "incentive"];
		for ( let t = 0; t < names.length; t++ ) {
			for ( let i = 0; i < 12; i++ ) {
				let name = names[t]+" "+i;
				name = name.charAt(0).toUpperCase() + name.slice(1);
				type = Math.random() < 0.5 ? "creature" : "spell";
				let atk = type == "creature" ? i : i*2;
				Game.cards_ar.push( 
					{ type: type, elementIndex: t, attack: atk, defense: i, cost: i, src: "images/sample-image.jpg", name: name, hp: (i+2)*5 }
				 );
			}
		}
	}
	*/
	
	Game.makeCardByName = function ( name ) {
		// console.log("makeCardByName( "+name+" )");
		let cards = Game.cards_ar.filter( card => card.name == name );
		let card = cards[0]; // There is only 1 card of each name
		// if property is an obj, pass a clone rather than reference
		let specials = cloneObject(card.specials);
		let misc = cloneObject(card.misc);
		/*
		 Also, cards should have (effects at end of owner's turn):

		 Owner Element modifiers: [w,x,y,z]
		 Opponent Element modifiers: [w,x,y,z]
		 Owner HP modifier: x
		 Opponent HP mofifier: x
		 Self (creature) HP modifier: x
		 Neighbors (creatures) HP modifiers: [x,y]
		 Siblings (creatures) HP modifier: x
		 */
		return new Card ( card.elementIndex, card.attack, card.defense, card.hp, card.cost, card.img, card.name, card.type, specials, card.description, misc );
	}

	Game.spawnCard = function ( name, slot ) {
		console.log("Game.spawnCard( "+name+")");
		let card = Game.makeCardByName( name );
		card.owner = slot.rack.owner;
		slot.rack.putCardInSlot( card, slot );
		card.undim();
		setTimeout ( function() {
			card.flip();
			Game.enqueueSummonPhaseSpecials( card, true ); // Make sure Forest Spider gets attack bonus from Minotaur
			// Game.executeSpecials( );
		}, 300 );
		
	}

	Game.pickCard = function ( elementIndex, cost ) {
		
		//	Select from the full card set, Game.cards_ar, a card of specified element type and cost 
		
		function meetsCriteria ( card ) {
			return card.elementIndex == elementIndex && card.cost == cost;
		}
		// create array of all cards that match the criteria.
		elegibleCards_ar = Game.cards_ar.filter( meetsCriteria );
		// then randomly pick one.
		let index = Math.floor( Math.random()*(elegibleCards_ar.length-1) );
		// console.log("index: "+index);
		if ( index == -1 ) {
			console.log( "tried to pickCard (elementIndex,cost): "+elementIndex+", "+cost);
		}
		if ( index != -1 ) {
			let name = elegibleCards_ar[ index ].name;
			return Game.makeCardByName( name );
		}
		
	}

	Game.GUIanimatePoints = function ( points, el ) {
		let pointsEl = document.createElement("span");
		let sign = points > 0 ? "positive" : "negative";		
		pointsEl.className = "points-field "+sign;
	}
	Game.unlockPlayableCards = function ( player ) {

		// Lock Cards in Deck that are not playable by player's elementValues

		let deck = player.deck.cards_ar;

		let elementValues = player.elementValues;

		// For each element, lock/unlock cards of that element which player can afford
		for ( let e = 0; e < elementValues.length; e++ ) {
			let elementIndex = e;
			let elementValue = elementValues[e];
			for ( let c = 0; c < deck.length; c++ ) {
				let card = deck[c];

				// If all Player Slots are filled, only Spell cards are eligible for unlocking
				if ( card.elementIndex === elementIndex ) {
					if ( card.cost > elementValue || ( !player.rack.slotAvailable && card.type === "creature" ) ) {
						card.lock();
					} else {
						card.unlock();
					}
				}
			}
		}
	}
















/*

.d8888. d8888b. d88888b  .o88b. d888888b  .d8b.  db      .d8888. 
88'  YP 88  `8D 88'     d8P  Y8   `88'   d8' `8b 88      88'  YP 
`8bo.   88oodD' 88ooooo 8P         88    88ooo88 88      `8bo.   
  `Y8b. 88^^’   88^^^^’ 8b         88    88^^^88 88        `Y8b. 
db   8D 88      88.     Y8b  d8   .88.   88   88 88booo. db   8D 
`8888Y' 88      Y88888P  `Y88P' Y888888P YP   YP Y88888P `8888Y' 
                                                                 
                                                                 
*/                                                 

                // Make Specials its own object? 
                // for organizational purposes?
	// Singleton ?
  //   Specials = {};
  //   Specials.events = [
  //   	"summon",
  //   	"summon-neighbor",
		// "summon-sibling",

		// "owner-turn-start",
		// "opponent-turn-start",

		// attack (this card attacks) (?)
		// neighbor-attack (?)
		// sibling-attack (?)
		// across-attack (?)
		// opponent-creature-attack(?)

		// "defend-self",
		// "owner-defend",
		// "neighbor-defend",

		// "die",
		
		// "cast",
		// "owner-cast"
  //   ]


	/////////////////////////////////////////////////
	//
	//			v Dev stuff for SPECIALS v
	//
	/////////////////////////////////////////////////

	Game.enqueueStartPhaseSpecials = function () {
		/*
			Check all cards for "owner-turn-start" and "opponent-turn-start" events.
			Enqueue Special, or enqueue Power Boost
		*/
		console.log("Game.enqueueStartPhaseSpecials()");
		let activeCards = Game.getAllCardsInRack( Game.activePlayer.rack );
		let passiveCards = Game.getAllCardsInRack( Game.passivePlayer.rack );
		// For active cards, check owner-turn-start specials
		for ( let card of activeCards ) {
			console.log(" - checking "+card.name+" for owner-turn-start...");
			for ( let special of card.specials ) {
				if ( special.event === "owner-turn-start" ) {
					if ( special.amount && special.amount instanceof Array && special.effect === "powers" ) {
						Game.queuePowerBoost( special.amount );
					} else {
						Game.enqueueSpecial ( special );	
					}
					
					console.log(" - found one!");
				}
			}
		}
		// For passive cards, check opponent-turn-start specials
		for ( let card of passiveCards ) {
			console.log(" - checking "+card.name+" for opponent-turn-start...");
			for ( let special of card.specials ) {
				if ( special.event === "opponent-turn-start" ) {
					if ( special.amount && special.amount instanceof Array && special.effect === "powers" ) {
						Game.queuePowerBoost( special.amount );
					} else {
						Game.enqueueSpecial ( special );	
					}
					console.log(" - found one!");
				}
			}
		}
	}


	Game.enqueueSummonPhaseSpecials = function ( card, executeImmediately ) {
		/*
				Check card for specials with "summon" event.
				Enqueue any found.
		*/
		console.log(" ::: Game.enqueueSummonPhaseSpecials( "+card.name+" )");
		executeImmediately = executeImmediately === true;
		let specials = [];
		// Check Self for "summon"
		specials = specials.concat( Game.getCardSpecialsOfType( card, "summon") );

		// Check Neighbors for "summon-neighbor"
		let neighbors = Game.getCardNeighbors( card );
		for ( let neighbor of neighbors ) {
			let neighborSpecials_ar = Game.getCardSpecialsOfType( neighbor, "summon-neighbor" );
			for ( let special of neighborSpecials_ar ) {
				// neighbors with "summon-neighbor" event should target only this card (the one just summoned)
				// NOT TRUE!  What if card with "summon-neighbor" has target "self" ?
				if ( card.misc && special.targetException && card.misc[special.targetException] == true ) {
					// This card is special's exception
					let index = neighborSpecials_ar.indexOf (special);
					neighborSpecials_ar.splice(index,1);
				} else {
					special.target = card;	
				}
			}
			specials = specials.concat( neighborSpecials_ar );

		}

		// Check Siblings for "summon-sibling"
		let siblings = Game.getSiblings( card );
		for ( let sibling of siblings ) {
			let siblingSpecials_ar = Game.getCardSpecialsOfType( sibling, "summon-sibling" );
			for ( let special of siblingSpecials_ar ) {
				if ( special.effect === "attack" && typeof special.amount === "number" ) {
					// Attack booster (Minotaur Commander or Orc Chieftain)
					
					if ( card.misc && special.targetException && card.misc[special.targetException] == true ) {
						// This card is special's exception
						let index = siblingSpecials_ar.indexOf (special);
						siblingSpecials_ar.splice(index,1);
					} else {
						special.target = card;	
					}
				} else {
					special.target = Game.getTargetsOfSpecial( special )[0];
					// Elemental
				}
				
				//Game.getTargetsOfSpecial( special )[0];
				// ^ Foolishly assuming targets[] here is length 1, because that's what it is when Fire Elemental targets "self"
				// ! But not when Minotaur targets siblings
			}
			specials = specials.concat( siblingSpecials_ar )
		}

		// Enqueue the Specials
		for ( let special of specials ) {
			if ( executeImmediately ) {
				//  We need this when multiple cards are summoned simultaneously (like Giant SPider)
				Game.executeSpecial( special );
			} else {
				Game.enqueueSpecial( special );	
			}
		}
	}


	Game.executeAttackPhaseSpecials = function ( card ) {
		/*
				Check card for specials with "attack" or "attack-across" event.
				Execute any found.
		*/
		console.log("Game.executeAttackPhaseSpecials("+card.name+")");
		let specials = [];
		// check self for "attack"
		specials = specials.concat( Game.getCardSpecialsOfType( card, "attack" ) );
		// check across for "attack-across"
		let acrossCard = Game.getCardAcross( card );
		if ( acrossCard != undefined ) {
			specials = specials.concat( Game.getCardSpecialsOfType( acrossCard, "attack-across" ) );	
		}
		// Execute the Specials
		for ( let special of specials ) {
			Game.executeSpecial( special );
		}
	}


	Game.executeDyingCardSpecial = function ( card ) {
		console.log("Game.executeDyingCardSpecial( "+card.name+" )")
		// Call this when a card dies.
		// Does this card have a special of event "die"?
		let specials = Game.getCardSpecialsOfType( card, "die" );
		
		if ( specials.length > 0 ) {
			// execute those specials...
			for ( let s = 0; s < specials.length; s++ ) {
				let special = specials[ s ];
				// Execute that special
				Game.executeSpecial( special );
			}
		}
	}




	Game.enqueueSpecial = function ( special ) {
		Game.specialsQueue.push( special );
	}

	Game.executeSpecials = function ( callback ) {
		if ( Game.specialsQueue.length > 0 ) { 
			Game.executeSpecial( Game.specialsQueue.pop() );
			let specialInterval = setInterval(
				function(){
					if ( Game.specialsQueue.length > 0 ) {
						Game.executeSpecial( Game.specialsQueue.pop() );
					} else {
						clearInterval ( specialInterval );
						if ( callback ) {
							callback();	
						}
					}		
				},
				1000
				);
		} else {
			callback();
		}
	}
/*
	Game.executeSpecial = function ( special ) {
		console.log("Game.executeSpecial("+special.card.name+", "+special.amount+")");

		if ( !Game.testSpecialConditional( special ) ) {
			return;
		}

		let card = special.card;
		if ( special.effect === "spawn" ) {
			// Spawn creature
			Game.executeSpawnSpecial ( special );
		//
		} else {
			let targets = Game.getTargetsOfSpecial( special );
			for ( let target of targets ) {
				Game.applySpecialAmountToTarget( special, target );
			}
		}
		
		if ( card.slot ) {
			card.flex();	
		}
		
	}
*/
	Game.executeSpecial = function ( special ) {
		console.log("Game.executeSpecial("+special.card.name+", "+special.amount+")");

		if ( !Game.testSpecialConditional( special ) ) {
			return;
		}

		let card = special.card;
		if ( special.effect === "spawn" ) {
			// Spawn creature
			Game.executeSpawnSpecial ( special );

		} else {
			let targets = Game.getTargetsOfSpecial( special );
			for ( let target of targets ) {
				if ( special.amount && special.amount instanceof Array && special.effect === "powers" ) {
					// add to each power
					target.addToElements( special.amount, true );

				} else if ( typeof special.amount === "number" ) {
					// direct property modification
					let amount = special.amount
					if ( special.effect === "hp" && amount < 0 ) {
						// How do we know if it's nonPhysical ?  
						let damage = special.amount * -1;
						amount = Game.checkSpecialDefend ( target, damage, special.isNonPhysical );
						amount *= -1;
					}
					target[special.effect] += amount;
				} else if ( typeof special.amount === "string" ) {
					// Elaborate string parsing...
					let amount = Game.specialGetStringamountAmount( special );
					if ( Game.specialGetStringAmountOperator( special ) === "=" ) {
						target[special.effect] = amount;
					} else {
						if ( special.effect === "hp" && amount < 0 ) {
							// How do we know if it's nonPhysical ?  
							let damage = amount * -1;
							amount = Game.checkSpecialDefend ( target, damage, special.isNonPhysical );
							amount *= -1;
						}
						target[special.effect] += amount;	
					}
					
				}
			}
		}
		
		if ( card.slot ) {
			card.flex();	
			Sounds.special.play();
		}
		
	}



	Game.executeSpawnSpecial = function ( special ) {
		/*
			Determine slots and spawn specified creatures into them
		*/
		console.log("Game.executeSpawnSpecial()" );
		let targetSlots = [];
		if ( special.target = "neighbor-slots" ){
			// Find available slots
			targetSlots = Game.getNeighborSlots( special.card.slot );
		} else if ( special.target = "sibling-slots" ) {
			targetSlots = Game.getSiblingSlots( special.card.slot );
		}
		targetSlots =  Game.getEmptySlots ( targetSlots );
		arrayShuffle( targetSlots );
		let numSpawns = Math.min ( special.amount, targetSlots.length );
		for ( let i = 0; i < numSpawns; i++ ) {
			// put spawn creature in available slot/s
			let slot = targetSlots[ i ];
			// spawn creature in that slot
			console.log(special);
			let creatureName = special.misc.spawn.type;
			Game.spawnCard( creatureName, slot );
		}
		
		/*
		"event" : "summon",
		"target" : "neighbor-slots",
		"effect" : "spawn",
		"amount" : 2,
		"misc" : { "spawn" : { "type" : "Forest Spider" } }
		*/
	}


	Game.checkSpecialDefend = function ( card, damage, isNonPhysical ) {
		/*
			Check for "defend-owner", "defend-sibling", "defend-neighbor" or "defend-self"
			that defend this card or player.
			Special modifies incoming damage. Return modified damage.
		*/
		console.log( "Game.checkDefendPhaseSpecials()");
		isNonPhysical = isNonPhysical === true ? true : false;
		let specials = [];
		// If target is a Player, not a Card
		if ( card instanceof Player ) {
			let player = card;
			// Check Player's cards 
			let children = Game.getAllCardsInRack( player.rack );
			for ( let child of children ) {
				specials = specials.concat( Game.getCardSpecialsOfType( child, "defend-owner" ) );
			}
		} else if ( card instanceof Card ) {
			// Check Self for "defend-self"
			specials = Game.getCardSpecialsOfType( card, "defend-self");
			let siblings = Game.getSiblings( card );
			// Do Siblings defend me?
			for ( let sibling of siblings ) {
				specials = specials.concat( Game.getCardSpecialsOfType( sibling, "defend-sibling" ) );
			}
			// Do Neighbors defend me?
			let neighbors = Game.getCardNeighbors( card );
			for ( let neighbor of neighbors ) {
				specials = specials.concat( Game.getCardSpecialsOfType( neighbor, "defend-neighbor") );
			}
		}

		for ( let special of specials ) {
			// Calculate damage modification
			if ( special.effect === "nonphysical-percent" && isNonPhysical ) {
				damage -= damage * special.amount;
			} else if ( special.effect === "physical-percent" && !isNonPhysical ) {
				damage -= damage * special.amount;
			} else if ( special.effect === "nonphysical-number" && isNonPhysical ) {
				damage -= special.amount;
			} else if ( special.effect === "physical-number" && !isNonPhysical ) {
				damage -= special.amount;
			}
		}
		damage = Math.max( 0, Math.round(damage) );
		return damage;
	}


/*
								Game.applySpecialAmountToTarget = function ( special, target ) {
									
									//		Update target's property value
									


									if ( special.amount && special.amount instanceof Array && special.effect === "powers" ) {
										// add to each power
										target.addToElements( special.amount );
									} else {
										// determine amount and property
										let amount = 0;
										let property = null;

										if ( typeof special.amount === "number" ) {
											// does target have that property?
											if ( target[special.effect] != undefined ) {
												target[special.effect] += special.amount;
											} else {
												// special.effect Special Case
												// eg. "defend"
												// Ignore it here?
											}
											
										} else if ( typeof special.amount === "string" ) {
											// Elaborate string parsing...
											
											let resultantPropertyValue = Game.specialApplyStringamountOperator ( special, target );
											// Apply Defense
											let modifiedDamage = Game.checkSpecialDefend( target, damage, false );
											target.takeDamage(modifiedDamage);
										}	
									}
								}
*/

								Game.getDamageOfSpecial = function ( special ) {
									/*
										How much damage does this special do to its target/s?
									*/
									if ( special.event.substring(0,6) == "defend" ) {
										return 0;
									}
									let amount = 0;
									if ( special.effect === "hp" ) {
										// Effect is damage 
										if ( typeof special.amount === "number" ) {
											amount = special.amount;
										} else if ( typeof special.amount === "string" ) {
											// Elaborate string parsing...
											amount = Game.specialGetStringamountAmount( special );
										}
										// damage is expected as a positive amount,
										// but stored as negative in special.amount
										return amount * (-1);
									}
									/*
									{
										"event" : "cast",
										"target" : "opponent",
										"effect" : "hp",
										"amount" : -6
									}
									*/
								}

	Game.executeCastPhaseSpecials = function ( card ) {
		// Redundant?  All cards of type "spell" have special with event "cast", yes?
		// Yes, but this collects all the specials.
		let specials = [];
		// Check Self for "cast"...
		specials = specials.concat( Game.getCardSpecialsOfType( card, "cast" ) );
		for ( let special of specials ) {
			if ( special.effect === "hp" ) {
				let damage = Game.getDamageOfSpecial( special );
				if ( damage > 0 ) {
					// If Damaging spell
					Game.specialExecuteDamageSpell( special );
				} else if ( damage < 0 ) {
					// If Healing spell
					Game.specialExecuteHealingSpell( special );
				}
					
			} else if ( special.effect === "powers" ) {
				let targets = Game.getTargetsOfSpecial( special );
				for ( let target of targets ) {
					target.addToElements( special.amount, true );	
				}
			}
		}
	}

	Game.specialExecuteDamageSpell = function ( special ) {
		console.log("Game.specialExecuteDamageSpell()");
		// Determine Spell's target/s
		let targets = [];

		// Get Targets
		targets = Game.getTargetsOfSpecial( special );
			
		// Calculate Damage
		let damage = Game.getDamageOfSpecial( special );
		// Apply Damage Modifiers
		let owner = special.card.owner;
		let ownerCards = Game.getAllCardsInRack( owner.rack );
		for ( let card of ownerCards ) {
			// Calculate damage modification
			let cardSpecials = Game.getCardSpecialsOfType( card, "owner-cast" );
			for ( let cardSpecial of cardSpecials ) {
				// If effect: "damage", 
				if ( cardSpecial.effect === "damage" ) {
					// Modify Damage
					damage = Game.specialModifySpellDamage ( damage, cardSpecial );
				}
			}
		}
		
		for ( let target of targets ) {
			// Apply Damage to each Target
			// Apply Damage Defense
			let modDamage = Game.checkSpecialDefend ( target, damage, true );
			target.takeDamage( modDamage );
		}
		
	}


	Game.specialExecuteHealingSpell = function ( special ) {

		// Determine Spell's target/s
		let targets = [];

		// Get Targets
		targets = Game.getTargetsOfSpecial( special );
			
		// Calculate Damage
		let healing = Game.getDamageOfSpecial( special ) *-1;
		// Are there such thing as Healing Modifiers ?
		
		
		for ( let target of targets ) {
			// Apply Healing to each Target
			target.hp += healing;
		}
		
	}

	Game.specialModifySpellDamage = function ( damage, special ) {
		// eg.
		/*
		"event" : "owner-cast",
		"target" : "current-spell",
		"effect" : "damage",
		"amount" : "x|x|x|*:1.5",
		*/
		/*
		"event" : "owner-cast",
		"target" : "spell",
		"effect" : "damage",
		"amount" : 1
		*/
		// Effect is damage 

		if ( typeof special.amount === "number" ) {
			damage += special.amount;
		} else if ( typeof special.amount === "string" ) {
			// Elaborate string parsing...
			damage = Game.specialStringcodeModifyDamage( special, damage );
		}
		
		return damage;
	}

								Game.executeSpellSpecial = function ( special ) {

									// Get Targets
									let targets = Game.getTargetsOfSpecial( special );
									// Determine Spell's damage/healing

									// Check Children for spell boosts

									// Check Spell modifier Specials (all cards in play)

									// Apply Spell effects to Targets

								}
	


	Game.specialStringcodeModifyDamage = function ( special, damage ) {

		
		return Game.specialApplyStringamountModifier( special, damage );

	}

	Game.specialApplyStringamountModifier = function ( special, amount ) {
		let string = special.amount;
		let parts = string.split('|');
		// modify amount?
		let modifier = 0;
		// Look for special symbols indicating modifier of result
		// !! Once we get this crazy "string formula" 
		//    system to work, the whole thing has
		//    to be redesigned.
		
		for ( let part of parts ) {
			let indicator = part.substring(0,2);
			if ( indicator === "+:"
			|| indicator === "-:"
			|| indicator === "/:"
			|| indicator === "*:"
			|| indicator === "v:" ) {
				// modifier = number
				modifier = Number (part.substring(2));
				switch ( indicator ) {
					case "+:":
						amount += modifier;
						break;
					case "-:":
						amount -= modifier;
						break;
					case "/:":
						amount /= modifier;
						break;
					case "*:":
						amount *= modifier;
						break;
					case "v:":
						amount = Math.min( amount, modifier );
					default:
						break;
				}
				break;
			}
		}
		return amount;
	}				

	Game.specialGetStringamountAmount = function( special ) {
		console.log("Game.specialGetStringamountAmount()");
		/*
			Decode amount from our tricky string special.amount formula,
			and return it:
		*/
		// operator | ref | property [@ index] | modifier
		// eg: - | owner | powers@0 | +:8
		// means: subtract ( value of owner's powers[0] +8 )
		// "amount" : "+|owner|powers@3|*:2"
		let string = special.amount;
		if ( string === "spell-table" ) {
			return 0;
		}
		let card = special.card;
		let parts = string.split('|');
		let amount = 0;
		
		// source reference
		let refString = parts[1]; 
		let ref;  // ref is the source, not the target
		switch ( refString ) {
			case "owner":
				ref = card.owner;
				break;
			case "opponent":
				ref = Game.getOpponent( card.owner );
				break;
			case "self":
				ref = card;
				break;
			case "across":
				ref = Game.getCardAcross( card );
				break;
			case "target":
				ref = special.targetCard;
				break;
			default: 
				// ?
				break;
		}

		// get amount via property key
		let prop = parts[2];
		
		if ( prop.includes("@") ) {
			// indicates prop element is array with index
			prop_ar = prop.split('@');
			prop = prop_ar[0];
			index = Number(prop_ar[1]);
			amount = ref[prop][index]; 
		} else {
			// 
			amount = ref[prop];
		}

		amount = Game.specialApplyStringamountModifier( special, amount );
		// Apply Stringamount Operator
		let operator = parts[0];
		switch ( operator ) {
			case "-":
				amount *= -1;
				break;
			case "+":
			default:
				amount = amount;
		}

		return amount;
	}
	Game.specialGetStringAmountOperator = function ( special ) {
		let parts = special.amount.split('|');
		return parts[0];
	}


/*
	Game.specialApplyStringamountOperator = function ( special ) {
		
		
			Return resultant property value (without updating the property),
			after applying baseAmount (number),
			using operation specified by special.amount (string)
		

		let baseAmount = Game.specialGetStringamountAmount( special );
		let string = special.amount;
		let parts = string.split('|');

		// how to apply amount to property ( add, divide, etc )
		operator = parts[0];
		let propValue = target[special.effect];

		switch ( operator ) {
			// case "Math.min":
			// 	propValue += amount; // Math.min was handled when getting amount
			// 	break;
			case "-":
				baseAmount *= -1;
				break;
			// case "/":
			// 	propValue /= amount;
			// 	break;
			// case "*":
			// 	propValue *= amount;
			// 	break;
			// case "=":
			// 	propValue = amount;
			// 	break;
			case "+":
			default:
				baseAmount = baseAmount;
				break;
		}
		return baseAmount;

	}
*/


	Game.cardHasSpecialOfType = function ( card, eventType ) {
		for ( let special of card.specials ) {
			if ( special.event === eventType ) {
				return true;
				break;
			}
		}
		return false;
	}

	Game.getCardSpecialsOfType = function ( card, eventType ) {
		console.log("Game.getCardSpecialsOfType( "+card.name+", "+eventType+")");
		let specials = [];
		for ( let special of card.specials ) {
			// check if that special has correct event type
			if ( special.event === eventType ) {
				specials.push( special );
			}
		}
		return specials;
	}

	Game.testSpecialConditional = function ( special ) {
		/*
			- helper function for Game.executeSpecial()
			Check if special has conditional and wheter it's satisfied

			// ref | property | comparison-operator | amount
			// eg. "misc" : { "conditional" : "owner|powers@3|>=|5" }
		*/

		if ( special.misc && special.misc.conditional ) {
			let card = special.card;
			let cond = special.misc.conditional;
			let propertyValue;
			let parts = cond.split("|");
			let ref = parts[0];
			switch ( ref ) {
				case "owner":
					ref = card.owner;
					break;
				case "opponent":
					ref = Game.getOpponent( card.owner );
					break;
				case "self":
					ref = card;
					break;
				case "across":
					ref = Game.getCardAcross( card );
					break;
					/*
					//Assume no plural refs
				case "neighbors":

					break;
				case "siblings":

					break;
				case "opponent-creatures":
					*/
					break;
				default:

			}

			// get amount via property key
			let prop = parts[1];
			if ( prop.includes("@") ) {
				// indicates prop element is array with index
				prop_ar = prop.split('@');
				prop = prop_ar[0];
				index = Number(prop_ar[1]);
				propertyValue = ref[prop][index];
			} else {
				// 
				propertyValue = ref[prop];
			}
			// get amount for comparison
			let amount = parts[3];
			// get comparison operator
			let operator = parts[2];
			switch ( operator ) {
				case ">":
					return propertyValue > amount;
					break;
				case "<":
					return propertyValue < amount;
					break;
				case ">=":
					return propertyValue >= amount;
					break;
				case "<=":
					return propertyValue <= amount;
					break;
				case "==":
					return propertyValue == amount;
					break;
				default: 
					return false;
					// ?
			}
			
		} else {
			// No contidional, automatically satisfied
			return true;
		}
		
	}


	Game.getTargetsOfSpecial = function ( special ) {
		/*
			Returns array of special's targets, determined by special's target string.
		*/
		let card = special.card;
		console.log("Game.getTargetsOfSpecial( "+card.name+", "+special.event+" )");
		if ( special.target instanceof Card ) {
			// target has been defined as specific card
			return [special.target];
		} else if ( Game.specialWhichNeedsTarget === special ) {
			return [special.targetCard];
		}
		let targets = [];
		let owner = card.owner;
		let opponent = owner === Game.activePlayer ? Game.passivePlayer : Game.activePlayer;
		// find target(s)
		switch ( special.target ) {
			case "all-creatures":
				let allCreatures = Game.getAllCardsInRack( opponent.rack ).concat( Game.getAllCardsInRack( owner.rack, card ));
				targets = targets.concat( allCreatures );
				break;
			case "owner":
			// Get Game.activePlayer
				targets.push(owner);
				break;
			case "neighbors":
			// Cards to left/right of this card
				targets = targets.concat( Game.getCardNeighbors( card ) );
				break;
			case "siblings":
			// All cards in Owner's rack, except special's card
				targets = targets.concat( Game.getAllCardsInRack( owner.rack, card ) );
				break;
			case "owner-creatures":
			// All cards_data in Owner's rack
				targets = targets.concat( Game.getAllCardsInRack( owner.rack ) );
				break;
			case "opponent":
			// Get Game.passivePlayer
				targets.push(opponent);
				break;
			case "opponent-creatures":
			// All cards_data in Opponent's rack
				targets = targets.concat( Game.getAllCardsInRack( opponent.rack ) );
				break;
			case "across":
			// Card in same slot index of opponent's rack
				let acrossCard = Game.getCardAcross( card );
				if ( acrossCard != undefined ) {
					targets.push( acrossCard );
				}
				break;
			case "self":
			// This card
				targets.push( card );
				break;
			default:
		}
		debugger;

		if ( special.targetException ) {
			for ( let t=targets.length-1; t >=0; t-- ) {
				let target = targets[t];
				if ( target.misc && target.misc[special.targetException] == true ) {
					targets.splice(t,1);
				}
			}
		}
		for ( let target of targets ) {
			let slotClause = target.slot != undefined ? ", slot "+target.slot.index : "";
		}

		return targets;
	}

	/*

	Casting special events: 
	"self-cast" - this spell card is played. 
	"owner-cast" - another of my owner's spell cards (not this card) is played.

	When a spell is cast,
	Check all cards (creatures in racks and spell played) for special.misc.spellDamageModifier,
	Parse the value string, [0] is operation. [1] is amount. (eg. Dragon's special)

	*/



	// Game.getOwnerCardsSpecials = function ( owner ) {
	// 	console.log("Game.getOwnerCardsSpecials()");
	// 	// list owner's cards
	// 	let ownerCards = Game.getAllCardsInRack( owner.rack );
	// 	// for each card
	// 	for ( let c = 0; c < ownerCards.length; c++ ) {
	// 		let card = ownerCards[c];
	// 		Game.getCardSpecialsOfType( card, eventType );
	// 	}

	// }


	//				^ End Game Object ^												//
	//  																			//
	//////////////////////////////////////////////////////////////////////////////////








/*
	8888888b.          d8b          888                   .d888      8888888888          888                     
	888   Y88b         Y8P          888                  d88P"       888                 888                     
	888    888                      888                  888         888                 888                     
	888   d88P .d88b.  888 88888b.  888888       .d88b.  888888      8888888    88888b.  888888 888d888 888  888 
	8888888P" d88""88b 888 888 "88b 888         d88""88b 888         888        888 "88b 888    888P"   888  888 
	888       888  888 888 888  888 888         888  888 888         888        888  888 888    888     888  888 
	888       Y88..88P 888 888  888 Y88b.       Y88..88P 888         888        888  888 Y88b.  888     Y88b 888 
	888        "Y88P"  888 888  888  "Y888       "Y88P"  888         8888888888 888  888  "Y888 888      "Y88888 
	                                                                                                         888 
	                                                                                                    Y8b d88P 
	                                                                                                     "Y88P"  
*/

	// =====================================================================================
	//
	//
	// 			v POINT OF ENTRY v
	//
	//
	// =====================================================================================

	Game.initGame();
	Sounds.initSounds();
	// Game.activePlayer = computerPlayer;
	// fillAIRack();
	// Game.startGame();
	





	// =====================================================================================
	//
	//
	// 			v TEMP SETUP STUFF v
	//
	//
	// =====================================================================================


	

	function AISelectCard () {
		console.log("AISelectCard()");
		// Select card from AI deck
		// Get Cards We can afford
		// Game.unlockPlayableCards( computerPlayer );
		let cards;
		if ( computerPlayer.rack.slotAvailable ) {
			cards = computerPlayer.deck.cards_ar.filter( card => !card.locked );
		} else {
			cards = computerPlayer.deck.cards_ar.filter( card => !card.locked && card.type == "spell" );
		}

		if ( cards.length > 0 ) {
			// Of those, randomly pick one
			// let card = cards[ Math.floor( Math.random()*cards.length ) ];
			// Pick the most expensive
			cards.sort( function(a,b) {
				return b.cost - a.cost;
			});
			let card = cards[0];
			console.log("card.cost: "+card.cost);

			// Display Selected card until Human player acknowledges (clicks)
			Game.selectCard( card );
			AIShowSelectedCard( card );
		} else {
			console.log("AI Can't afford a card");
			Game.skipTurn();
		}
		
	}
	function AIShowSelectedCard () {
		console.log("AIShowSelectedCard()");
		let displayCard = Game.duplicateCard ( Game.selectedCard );
		displayCard.undim();
		displayCard.flip(true);
		displayCard.flip();
		// displayCard.el.style.transformOrigin = "top left";
		// displayCard.shadow.style.transformOrigin = "top left";
		// $(displayCard.el).css("transform","scale(2)");
		// $(displayCard.shadow).css("transform","scale(2)");
		// let pos = $(AICardGrid).position();
		displayCard.x = 200;
		displayCard.y = 50;
		// displayCard.width = cardWidth*2;
		// displayCard.height = cardHeight*2;
		console.log("displayCard.x: "+displayCard.x);

		// When user clicks the card...
		let evt = isTouch ? 'touchend' : 'click';
		$(displayCard.el).on( evt, () => {
			
			AIPlayCard ( );
			displayCard.kill( true );
			computerPlayer.deck.lock();
			// Game.endPhase();
			// Game.resolveAttacks();
		} );
		
	}
	function AIPlayCard () {
		console.log("AIPlayCard()");
		let card = Game.selectedCard;
		// If creature, 
		if ( card.type == "creature" ) {
			// pick a slot
			let slots_ar = computerPlayer.rack.getEmptySlots();
			let slot = slots_ar[ Math.floor( Math.random()*slots_ar.length ) ];
			// Put creature in slot
			Game.playCreatureCard( card, slot );
		} else if ( card.type == "spell" ) {

			// Or, if spell,

			// Cast it...
			Game.playSpellCard( card );
		}

		

		
	}

	function fillAIRack () {
		for ( let s = 0; s < 6; s++ ) {
			let slot = computerPlayer.rack.slots[s];

			// select creature to play
			let card = AIPickCreatureToPlay();

			// play card
			Game.playCreatureCard( card, slot );
		}
	}
	function AIPickCreatureToPlay(){
		
		// console.log("computerPlayer.deck: ");
		// console.log(computerPlayer.deck);
		let cards = computerPlayer.deck.cards_ar.filter( card => !card.locked && card.type == "creature" );
		let index = Math.floor( cards.length * Math.random() );
		let creatureCard = cards[index];
		return creatureCard;
	}

/*
Game.checkCreatureEvents = function( playerUp ) {

			let ownerCreatures = [],
				opponentCreatures = [];
			// For each ActivePlayer's creature
			for ( let s = 0; s < Game.activePlayer.rack.slots.length; s++ ) {
				let slot = Game.activePlayer.rack.slots[s];
				if ( slot.card != undefined ) {
					ownerCreatures.push( slot.card );
				}
			}
			// For each PassivePlayer's creature
			for ( let s = 0; s < Game.passivePlayer.rack.slots.length; s++ ) {
				let slot = Game.passivePlayer.rack.slots[s];
				if ( slot.card != undefined ) {
					opponentCreatures.push( slot.card );
				}
			}

			let card = slot.card

			// Check card for special events
			if ( card.special != undefined && card.special.event == playerUp ) {
				if ( card.damage > 0 ) {
					switch (card.special.target) {
						case "owner":
							card.owner.takeDamage( card.special.damage );
							break;
						case "owner-creatures-all":
							// Get card's slot index
							let index = card.slot.index;
							if ( index > 0 ) {
								// Get slot to left
								let leftSlot = card.slot.rack.slots[ index -1 ];
								if ( leftSlot.card != undefined ) {
									leftSlot.card.takeDamage( card.special.damage );
								}
							}
							if ( index < card.slot.rack.slots.length -1 ) {
								// Check Slot to right
								let rightSlot = card.slot.rack.slots[ card.slot.index + 1];
								if ( rightSlot.card != undefined ) {
									rightSlot.card.takeDamage( card.special.damage );
								}
							}
							
							break;
						case "owner-creatures-neighbors":

							break;
						case "opponent":

							break;
						case "opponent-creatures-all":

							break;
						case "opponent-creature-across":

							break;
						case "creature-self":

						default:


					}
				}
			}
		}
		*/
			/*
		SPECIAL
			EVENTS
				"summon"
				"die"
				"owner-turn-start"
				"owner-turn-end"
				"opponent-turn-start"
				"opponent-turn-end"
			ACTIONS
				"heal"
				"damage"
				"element-powers"
			TARGET
				"owner"
				"owner-creatures-all"
				"owner-creatures-neighbors"
				"opponent"
				"opponent-creatures-all"
				"opponent-creature-across"
				"creature-self"
*/

	/*
	=====================================================
	//
	//				UTILITY FUNCTIONS
	//
	=====================================================
	*/
	function arrayDeDuplicate(array) {
		var a = array.concat();
		for(var i=0; i<a.length; ++i) {
			for(var j=i+1; j<a.length; ++j) {
				if(a[i] === a[j])
					a.splice(j--, 1);
			}
		}
		return a;
	}
	/**
	 * Randomly shuffle an array
	 * https://stackoverflow.com/a/2450976/1293256
	 * @param  {Array} array The array to shuffle
	 * @return {String}      The first item in the shuffled array
	 */
	var arrayShuffle = function (array) {

		var currentIndex = array.length;
		var temporaryValue, randomIndex;

		// While there remain elements to shuffle...
		while (0 !== currentIndex) {
			// Pick a remaining element...
			randomIndex = Math.floor(Math.random() * currentIndex);
			currentIndex -= 1;

			// And swap it with the current element.
			temporaryValue = array[currentIndex];
			array[currentIndex] = array[randomIndex];
			array[randomIndex] = temporaryValue;
		}

		return array;

	};


	function cloneObject(obj) {
	    var copy;

	    // Handle the 3 simple types, and null or undefined
	    if (null == obj || "object" != typeof obj) return obj;

	    // Handle Date
	    if (obj instanceof Date) {
	        copy = new Date();
	        copy.setTime(obj.getTime());
	        return copy;
	    }

	    // Handle Array
	    if (obj instanceof Array) {
	        copy = [];
	        for (var i = 0, len = obj.length; i < len; i++) {
	            copy[i] = cloneObject(obj[i]);
	        }
	        return copy;
	    }

	    // Handle Object
	    if (obj instanceof Object) {
	        copy = {};
	        for (var attr in obj) {
	            if (obj.hasOwnProperty(attr)) copy[attr] = cloneObject(obj[attr]);
	        }
	        return copy;
	    }

	    throw new Error("Unable to copy obj! Its type isn't supported.");
	}





	// End Game namespace
})(this);
</script>
</body>
</html>