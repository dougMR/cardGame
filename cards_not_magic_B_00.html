<!doctype html>
<html>
<head>

<!-- import TweenMax and jquery -->

<!-- 
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://s0.2mdn.net/ads/studio/cached_libs/tweenmax_1.19.1_92cf05aba6ca4ea5cbc62b5a7cb924e3_min.js"></script> -->

<script src="libs/jquery-2.1.0.js"></script>
<script src="libs/TweenMax.min.js"></script>
<script type="text/javascript" src="data/cards.json"></script>

<style>
html, body {
	width: 100%;
	height: 100%;
	margin: 0;
}
body {
	background-image: url('images/bg-texture-stone.jpg');
}
#game-container {
	/*border: 1px dashed orange;*/
	position: relative;
	width: 800px;
	transform-style: preserve-3d;
	perspective: 2000px;
	transform: scale( 1 );
}
#player-card-deck {
	position: absolute;
	left: 440px;
	top: 360px;
	background: rgba(255, 255, 255, 0.5);
	border: 2px solid black;
	box-sizing: border-box;
}
.game-element {
	position: absolute;
	box-sizing: border-box;
}
.player-element {
	position: absolute;
	border: 2px solid brown;
}
.player-element .portrait {
	display: block;
	width: 110px;
	height: 110px;
}
.player-element-field, .player-hp-field, .player-field {
	position: absolute;
	/*display: block;*/
	box-sizing: border-box;
	font-size: 1em;
	color: white;
	font-family: serif;
	border: 1px solid brown;
	background: rgba(0,0,0,0.4);
	text-align: center;
	padding: 0.2em 0.3em;
}
.player-field {
	white-space: nowrap;
	}
.player-hp-field {
	font-family: sans-serif;
	font-weight: bold;
}

/* 
 -----------------------------
	
	CARD

 -----------------------------
*/
.card {
	font-family: sans-serif;
	font-size: 10px;
	color: #333;
	/*box-shadow: 5px 5px 6px rgba(0,0,0,0.5);*/
	transform-style: preserve-3d;
}
.card, .card-front, .card-back, .card-shadow, .card-hilite, .card-dim, .card-slot {
	position: absolute;
/*	width: 100px;
	height: 147px;*/
	border-radius: 1em;
	box-sizing: border-box;
}
.card-hilite {
	box-shadow: 0px 0px 12px 6px rgba(255,255,0,0.6);
}
.card-dim { 
	background-color: rgba(128,128,128,0.5);
	visibility: visible;
	/*border: 2px solid grey;*/
	/*z-index: 1000;*/
	/*backface-visibility: visible;*/
	visibility: visible;
	width: 100%;
	height: 100%;
	transform: rotateY( 180deg );
 }
.card-front, .card-back {
	-webkit-backface-visibility: hidden;
	-moz-backface-visibility: hidden;
	backface-visibility: hidden;
	/*border: 2px solid grey;*/
	
	padding: 0.5em;
}
.card-front {
	background-color: #fdf2e2;
	background-image: url('images/bg-texture-light-300x300.jpg');
	background-size: cover;
	transform: rotateY( 180deg );
}
.card-back {
	background-color: brown;
	background-image: url('images/tcgplayer-logo-color_320x120.png'), url('images/bg-texture-300x300.jpg');
	background-position: center 45%, center;
	background-repeat: no-repeat, no-repeat;
	background-size: 90% auto, cover;
	/* z-index: 2; */
	/*transform: rotateY( 0deg );*/
	/*background-size: contain;*/
	/*border: 1px solid black;*/
}
.card span {
	margin-right: .2em;
	border-radius: 1em;
}
/*.card .cost {
	font-weight: 900;
	background-color: white;
	padding: .1em;
	border: 1px solid #b89f94;
	text-align: center;
	display: inline-block;
}*/
.card .title {
	font-weight: 900;
	font-family: serif;
	font-size: 1.5em;
	color: #6d5246;
}
.card .title:after {
	white-space: pre;
	content:'\A';
}
.card .illustration-creature, .card .illustration-spell {
	border: 2px solid #b89f94;
	border-color: #b89f94 #d4c2ba #dacac3 #c4aba1;
	width: 100%;
	height: auto;
	box-sizing: border-box;
}
.card .illustration-spell {
	border-radius: 50%;
}
.card .attributes {
	text-align: right;
}
.card .attributes span {
	font-weight: bold;
	background-color: white;
	padding: .1em .2em;
	border: 1px solid black;
	text-align: center;
	display: inline-block;
	vertical-align: middle;
}
.card .attributes .attack {
	background-color: #ff8a8a;
}
.card .attributes .defense {
	background-color: #8abbff;
}
.card .attributes .cost {
	background-color: #ffe647;
}
.card .attributes .hp {
	background-color: #8aff9b;
}
.card-shadow {
	box-shadow: 0px 0px 10px 4px rgba(0,0,0,0.5);
	transform-style: preserve-3d;
	/*margin: 10px 0 0 10px;*/
	background-color: rgba(0,0,0,0.5);
}

/* 
 -----------------------------
	
	CARD RACK

 -----------------------------
*/
.card-slot {
	position: absolute;
	background-color: rgba( 128, 128, 255, 0.5 );
	border: 1px solid white;
	box-shadow: inset 0 0 1em rgba(0,0,0,0.5);
}
.card-rack {
	border: 1px solid black;
	background-color: rgba( 255, 255, 255, 0.65 );
	box-shadow: inset 0 0 20px brown;
}

#bg {
	position: absolute;
	width: 100%;
	height: 100%;
	background-color: rgba(0,0,0, 0.5);
}
#layout {
	position: absolute;
	display: block;
	background: url( "images/gameplay_spectromancer.jpg" );
	background-repeat: no-repeat;
	background-size: contain;
	width: 900px;
	height: 100%;
	/*border: 2px dashed yellow;*/
	
}
#ai-cards {
	position: absolute;
	top: 450px;
	left: 10px;
	padding: 15px;
	box-sizing: border-box;
	border: 1px solid white;
	box-shadow: inset 0 0 20px black;
	transform-origin: top left;
	transform: scale(0.6);
}

/* 
 -----------------------------
	
	GUI

 -----------------------------
*/
.points-field { 
	position: absolute;
	font-family: sans-serif;
	font-weight: bold;
	font-size: 1em;
	width: 4em;
	margin-right: -2em;
	margin-top: -0.5em;
}
.points-field.positive {
	color: green;
	text-shadow:
	   -1px -1px 0 #FFF,  
	    1px -1px 0 #FFF,
	    -1px 1px 0 #FFF,
	     1px 1px 0 #FFF;
}
.points-field.negative {
	color: red;
	text-shadow:
	   -1px -1px 0 #000,  
	    1px -1px 0 #000,
	    -1px 1px 0 #000,
	     1px 1px 0 #000;
}

.turn-counter {
	position: absolute;
	left: 10px;
	top: 150px;
	border: 1px solid brown;
	box-shadow: 0 0 10px black;
	box-sizing: border-box;
	padding: 0.5em;
	font-size: 1em;
	color: black;
	font-family: sans-serif;
	text-align: center;
}

</style>

</head>
<body>
<!-- <span style="font-family: sans-serif; font-size: 0.5em; color: #555;" >Tested in webkit</span> -->
<!-- <img id="layout" src="images/gameplay_spectromancer.jpg" /> -->
<!-- <div id="layout"></div> -->
<!-- <div id="bg"></div> -->
<div id="ai-cards"></div>
<!-- 



Currently, card deck is only generated once, as part of the process of creating a player (either Human or AI).  Need to allow for changing cards in a deck.

Deck.changeCards() ? 
























 -->
<script>
let Game = (function(namespace){
	// Isolated namespace for all this code...

	let isTouch = ("touchstart" in document.documentElement);
	let cardWidth = 94,
		cardHeight = 126,
		gameContainer = document.createElement("div");
	gameContainer.id = "game-container";
	document.body.appendChild(gameContainer);

	let playerCardGrid = document.createElement("div");
	playerCardGrid.id = "player-card-deck";
	$(playerCardGrid).css({width: cardWidth*4 +30, height: cardHeight*4 +30, padding: 15});
	gameContainer.appendChild( playerCardGrid );

	let AICardGrid = document.getElementById("ai-cards");
	$(AICardGrid).css({width: cardWidth*4 +30, height: cardHeight*4 +30});

	let turnCountField = document.createElement("span");
	$(turnCountField).addClass("turn-counter");
	gameContainer.appendChild(turnCountField);

	let computerPlayer, livePlayer;


	/////////////////////////////////////////////////////
	//
	//	GAME ELEMENT CLASS -- Not sure we need this
	//
	/////////////////////////////////////////////////////
	/* 
	*  GameElement is basic model for a 'physical' game piece - eg. Card, slot, etc
	*  Not to be confused with the Game object, which is not to be confused with the Game namespace
	*/

	class GameElement {
		constructor ( el ) {
			// console.log('GameElement constructor()');
			this._x = 0, this._y = 0;
			this._myEl = el;
			this._height = $(el).outerHeight();
			this._width = $(el).outerWidth();
			$(this._myEl).addClass("game-element");
		}
		animateTo( x, y ) {
			if ( typeof x === "number" && typeof y === "number" ) {
				this._y = y;
				this._x = x;
				let dur = 1;
				TweenMax.to( this._myEl, dur, {css:{left: this._x, top: this._y}, delay: 0, ease:Power2.easeIn});
			}
		}
		kill () {
			$(this.el).remove();
			delete this;
		}
		// getters & setters
		set x ( value ) {
		 	if ( value != undefined ) {
		 		this._x = value;
				$(this._myEl).css("left",value);
	 			// TweenMax.set( this._myEl, {x:value});
		 	}
		 }
		get x () {
			// console.log("GameElement.get x");
			return this._x;
		}
		set y ( value ) {
		 	if ( value != undefined ) {
		 		this._y = value;
				$(this._myEl).css("top",value);
		 		// TweenMax.set( this._myEl, {y:value});	
		 	} 
		 }
		get y () {
			return this._y;
		}
		get el () {
			return this._myEl;
		}
		set height ( value ) {
			if ( value != undefined ) {
				TweenMax.set( this._myEl, {height:value});
				this._height = value;
			}
		}
		get height () {
			return $(this.el).outerHeight();
		}
		set width ( value ) {
			if ( value != undefined ) {
				TweenMax.set( this._myEl, {width:value});
				this._width = value;
			}
		}
		get width () {
			return $(this.el).outerWidth();
		}
	}












	///////////////////////////////////////////
	//
	//		CARD CLASS
	//
	///////////////////////////////////////////

	class Card extends GameElement {

		/*
		Handle non-attack effects for each card
		...
		Damage host 
		Damage enemy
		Heal host
		Increase host element power
		Decrease host element power
		Decrease enemy element power
		Effects at start or end of owner's turn,
		Effects at start or end of enemy's turn
		Effects on summon
		Effects on "die"
		Also, cards should have (effects at end of owner's turn):

		Owner Element modifiers: [w,x,y,z]
		Opponent Element modifiers: [w,x,y,z]
		Owner HP modifier: x
		Opponent HP mofifier: x
		Self (creature) HP modifier: x
		Neighbors (creatures) HP modifiers: [x,y]
		Siblings (creatures) HP modifier: x

		For Spells:

		// Does the spell operate automatically?

			// on the Active player?

			// and/or on the Passive player?

			// and/or on Active player card?

			// and/or on Passive player card?

		// Or does spell require clicking on a target card?

			// Owner's card?

			// Opponent's card?
		*/

		constructor ( ele, atk, def, hp, cost, img, tit, type, specials ) {
			// console.log('Card constructor('+ele+', '+atk+', '+def+', '+cost+', '+img+', '+tit+', '+hp+')');
			let _el = document.createElement("div");
			super( _el );
			this.init(atk, def, cost, img, tit, ele, hp, type);
		}

		init ( atk, def, cost, img, tit, ele, hp, type ) {
			this._type = type; // "creature" or "spell"
			this._faceShowing = -1;
			this._attack = atk != undefined ? atk : 0;
			this._defense = def != undefined ? def : 0;
			this._cost = cost != undefined ? cost : 0;
			this._level = this._attack + this._defense + this._cost;
			this._imgSrc = img != undefined ? img : "";
			this._title = tit != undefined ? " "+tit : "...";	
			this._specials = {},
			this._shadowEl = document.createElement("div");
			this._hp = this._maxhp = hp;
			this._locked = false;
			this.assemble();
			this.attack = atk;
			this.defense = def;
			this.cost = cost;
			this.elementIndex = ele;
			this._slot = null;
			this._turnPlayed = Game.turnNum;
			// HACK !!!
			if ( this.title === "Fire Drake" ) {
				this._turnPlayed--;
			}
			this._owner = null;
			// 
			let evt = isTouch ? 'touchend' : 'click';
			$(this.el).on( evt, () => {
				this.select() 
			} );
		}

		assemble () {
			// Assemble Me
			// console.log("Card.assemble()");
			$(this.el).addClass("card");
			// Front
			this._front = document.createElement("div");
			this._front.className = "card-front";
			// Back
			this._back = document.createElement("div");
			this._back.className = "card-back";
			// Title
			this._titleEl = document.createElement("span");
			this._titleEl.className = "title";
			// Level
			// this._lvlEl = document.createElement("span");
			// this._lvlEl.className = "level";
			// Attributes
			this._attributesEl = document.createElement("div");
			this._attributesEl.className = "attributes";
			// Attack
			this._atkEl = document.createElement("span");
			this._atkEl.className = "attack";
			// Defense
			this._defEl = document.createElement("span");
			this._defEl.className = "defense";
			// Cost
			this._costEl = document.createElement("span");
			this._costEl.className = "cost";
			// HP
			this._hpEl = document.createElement("span");
			this._hpEl.className = "hp";
			// Image
			this._imgEl = document.createElement("img");
			this._imgEl.className = "illustration-"+this._type;
			// Shadow
			this._shadowEl.className = "card-shadow";
			// Dim cover
			this._dimEl = document.createElement("div");
			this._dimEl.className = "card-dim";
			// 
			this.el.appendChild(this._front);
			this.el.appendChild(this._back);
			this.el.appendChild(this._dimEl);
			// this._front.appendChild(this._lvlEl);
			
			this._front.appendChild(this._titleEl);
			this._front.appendChild(this._imgEl);
			this._front.appendChild(this._attributesEl);
			this._attributesEl.appendChild(this._atkEl);
			this._attributesEl.appendChild(this._defEl);
			this._attributesEl.appendChild(this._costEl);
			this._attributesEl.appendChild(this._hpEl);
			gameContainer.appendChild(this._shadowEl);
			gameContainer.appendChild(this.el);
			TweenMax.set(this._front, { width: cardWidth, height: cardHeight });
			TweenMax.set(this._back, { width: cardWidth, height: cardHeight });
			TweenMax.set(this._shadowEl, { width: cardWidth, height: cardHeight, transform:"translateZ(0px)" });
			TweenMax.set(this.el, { width: cardWidth, height: cardHeight, transform:"translateZ(2px)" });
		}

		changeParent ( el ) {
			if ( el instanceof HTMLElement ) {
				$(this._shadowEl).detach();
				$(el).append($(this._shadowEl));
				
				$(this.el).detach();
				$(el).append($(this.el));
			}
		}
		
		update ( ) {
			// console.log("Card.update()")
		 	this._atkEl.textContent = this._attack;
		 	this._defEl.textContent = this._defense;
		 	this._costEl.textContent = this._cost;
		 	// this._lvlEl.textContent = this._level;
		 	this._titleEl.textContent = this._title;
		 	this._hpEl.textContent = this._hp;
		 	this._imgEl.src = this._imgSrc;
		 }

		 takeDamage ( value ) {
		 	console.log("Card.takeDamage( "+value+" )");
		 	if ( value != undefined ) {
		 		this.hp -= value;
		 	}
		 }

		kill () {
			console.log("Card.kill()");
			console.log("my slot: "+this.slot);
			$(this._shadowEl).remove();
			if ( this.slot != undefined ) {
				this.slot.card = null;
			}
			
			super.kill();
		}

		setSelectBehavior ( func ) {
			// console.log("Card.setSelectBehavior( "+func+" )");
			this._onSelectFunction = func;
		}
		removeSelectBehavior ( func ){
			this._onSelectFunction = null;
			
			let evt = isTouch ? 'touchend' : 'click';
			if ( func ) {
				$(this.el).off( evt, func );
			} else {
				$(this.el).off( evt );
			}
			
		}
		lock () {
			this._locked = true;
			this.dim();
			this.deselect();
		}
		unlock () {
			this._locked = false;
			this.undim();
		}
		dim () {
			this._dimEl.style.visibility = "visible";
		}
		undim () {
			this._dimEl.style.visibility = "hidden";
		}
		select () {
			console.log("Card.select()");
			console.log("_locked: "+this._locked);
			if ( !this._locked ) {
				try { this._onSelectFunction() }
				catch (error) { console.log( "ERROR:  "+error ) };
				// this.hilite();
			}
		}
		deselect () {
			if ( this._onDeselectFunction ) {
				this._onDeselectFuntion();
			}
			if ( Game.selectedCard === this ) {
				Game.selectedCard = null;
			}
			this.unhilite();
		}

		hilite( ) {
			this.el.style.border = "2px solid black";
			this.el.style.boxShadow = " 0px 0px 10px 10px yellow";
		}

		unhilite () {
			this.el.style.border = "none";
			this.el.style.boxShadow = "none";
		}

		flip ( immediate ) { //x, y

			// set up Tween parameters
			if ( document.contains( this.el ) ) {
				let c = this;
				let rotY = c._faceShowing === 1 ? "+=180" : "-=180";
				if ( immediate ) {
					TweenMax.set( c.el, {rotationY: rotY});
				} else {
					// let x2 = x == undefined ? c._x : x;
					// let y2 = y == undefined ? c._y : y;
					// let dx = x2-c._x, dy = y2-c._y;
					// let dist = Math.sqrt( dx*dx + dy*dy );
					// let dur = 0.4 + 0.5 * dist / 700;
					let dur = 0.4;

					// card
					TweenMax.to( c.el, dur, {css:{rotationY: rotY}, delay: 0, ease:Power2.easeIn});
					TweenMax.to( c.el, dur, {css:{z:"+=200"}, yoyo:true, repeat:1, ease:Sine.easeInOut});
					// TweenMax.to( c.el, .75*dur, {css:{x:x2, y:y2}, ease:Power2.easeOut});
					// shadow
					TweenMax.to(c.shadow, dur, {css:{rotationY: rotY}, delay: 0, ease:Power2.easeIn});
					TweenMax.to(c.shadow, dur, {css:{z:"+=200"}, yoyo:true, repeat:1, ease:Sine.easeInOut});
					// TweenMax.to(c.shadow, .75*dur, {css:{x:x2, y:y2}, ease:Power2.easeOut});
				}			
				this._faceShowing *= -1;
			}
		}

		removeEl () {
			if ( gameContainer.contains( this.el )) {
				gameContainer.removeChild( this.el );
			}
			if ( gameContainer.contains( this._shadowEl )) {
				gameContainer.removeChild( this._shadowEl );	
			}
		}

		// getters + setters 
		get locked () {
			return this._locked;
		}

		set owner ( value ) {
			if ( value instanceof Player ) {
				this._owner = value;
			}
		}
		get owner () {
			return this._owner;
		}

		set slot ( value ) {
			if ( value instanceof Slot ){
				this._slot = value;	
			}
		}
		get slot () {
			return this._slot;
		}

		set attack ( value ) {

			if ( value != undefined ) {
				this._attack = value;
				// this._level = this._attack + this._defense + this._cost;
				this.update();
			} 
		}
		get attack() {
			return this._attack;
		}
						
		set defense ( value ) {
		 	if ( value != undefined ) {
		 		this._defense = value;
		 		// this._level = this._attack + this._defense + this._cost;
		 		this.update();
		 	} 
		 }
		get defense () {
		 	return this._defense;
	 	}
		 				
		set cost ( value ) {
		 	if ( value != undefined ) {
		 		this._cost = value;
		 		// this._level = this._attack + this._defense + this._cost;
		 		this.update();
		 	} 
		 }
		get cost () {
		 		return this._cost;
	 	}

	 	set hp ( value ) {
	 		if ( value != undefined ) {
	 			this._hp = Math.min( value, this._maxhp );
	 			this.update();
				if ( this.hp <= 0 ) {
		 			this.kill();
		 		}
	 		}
	 	}
	 	get hp () {
	 		return this._hp;
	 	}
		
		get img () {
	 		return this._imgSrc;
	 	}
		
		get title () {
	 		return this._title;
	 	}
		 
		get shadow () {
			return this._shadowEl;
		}

		set x ( value ) {
			if ( typeof value === "number" ) {
				super.x = value;
				$(this._shadowEl).css("left", value);
				// TweenMax.set( this._shadowEl, {x:value});
			}
		}
		get x () {
			return this._x;
		}
		set y ( value ) {
			if ( typeof value === "number" ) {
				super.y = value;
				$(this._shadowEl).css("top", value);
				// TweenMax.set( this._shadowEl, {y:value});
			}
		}
		get y () {
			return this._y;
		}
		get type () {
			return this._type;
		}
		set type ( value ) {
			if ( value === "creature" || value === "spell" ) {
				this._type = value;
			}
		}

		get turnPlayed () {
			return this._turnPlayed;
		}
	}

	// -- End Card Constructor







	



	///////////////////////////////
	//
	//		Player Class
	//
	///////////////////////////////
	/*
		The entity that uses the cards
	*/
	class Player extends GameElement {
		constructor ( name, portraitSrc ) {
			console.log('Player constructor()');
			let _el = document.createElement("div");
			super( _el );
			this._size = 110;
			this._el = _el;
			this._name = name;	
			this.portraitSrc = portraitSrc != undefined ? portraitSrc : "player_default.gif";
			this.init();
			this.assemble();
		}

		init () {
			$(this._myEl).addClass("player-element");
			this._portraitImg = document.createElement("img");
			this._portraitImg.className = "portrait";
			this._portraitImg.src = "images/"+this.portraitSrc;
			this._elementValues = [1,1,1,1];
			this._elementNames = [ "supplies", "downtime", "productivity", "incentives" ];
			this._hp = 100;
			this.rack = new Rack( this );
			this.deck = new Deck( this );
			// console.log("this.deck: "+this.deck);
			// console.log(this.deck);
			// console.log("this.deck.x: "+this.deck.x);
		}
		assemble () {
			this._el.appendChild(this._portraitImg);
			gameContainer.appendChild(this._el);
			// HP
			let _hp_el = document.createElement("span");
			_hp_el.className = "player-hp-field";
			this._el.appendChild( _hp_el );
			this.hpField = _hp_el;
			this.hp = this._hp;
			// ELEMENTS
			let _elementField0 = document.createElement("span");
			let _elementField1 = document.createElement("span");
			let _elementField2 = document.createElement("span");
			let _elementField3 = document.createElement("span");
			this._elementFields = [_elementField0, _elementField1, _elementField2, _elementField3];
			// position them
			for ( let i = 0; i < this._elementFields.length; i++ ){
				let field = this._elementFields[i];
				field.className = "player-element-field";
				field.innerHTML = this._elementNames[i] + ": <br/>" + this._elementValues[i];
				this._el.appendChild( field );
			}
			// NAME
			this.nameField = document.createElement("span");
			this.nameField.className = "player-field";
			this._el.appendChild( this.nameField );
			this.nameField.textContent = this.name;
		}
		
		takeDamage( value ) {
			console.log("Player.takeDamage( "+value+" )");
			this.hp =  this.hp - value;
		}
		position ( xvalue, yvalue ) {
			this._x = xvalue;
			this._y = yvalue;
		}
		// 
		setElement ( index, value ) {
			if ( index != undefined && value != undefined ) {
				this._elementValues[ index ] = value;
				this._elementFields[ index ].innerHTML = this._elementNames[ index ] + ": <br/>" + value;
			}
		}
		getElement ( value ) {
			let index = typeof value === "number" ? value : this._elementNames.indexOf( value );
			if ( index === Number.parseInt( index, 10 ) ) {
				return this._elementValues[ index ];
			}
		}
		subtractFromElement ( index, value ) {
			console.log("Player.subtractFromElement( "+index+", "+value+")");
			if ( index === Number.parseInt( index, 10 ) && typeof value === "number" ) {
				this.setElement( index, this.getElement( index ) - value );
			}
		}
		addToElement ( index, value ) {
			if ( index === Number.parseInt( index, 10 ) && typeof value === "number" ) {
				this.setElement( index, this.getElement( index ) + value );
			}
		}
		// getters & setters
		get name () {
			return this._name;
		}
		set hp ( value ) {
		 	if ( value != undefined ) {
		 		this._hp = value;
		 		this.hpField.textContent = value;
		 	}
		 }
		get hp () {
			return this._hp;
		}
		get elementValues () {
			return this._elementValues.slice(0);;
		}
		set elementValues ( ar ) {
			if ( Array.isArray( ar ) ) {
				for ( let i = 0; i < this._elementValues.length; i++ ) {
					if ( typeof ar[0] === "number") {
						this._elementValues[i] = ar[i];
					}
				}
			}
		}
		set x( value ) {
			if ( value != undefined ) {
				super.x = value;
				this.rack.x = this._x + 260;
			}
		}
		get x() {
			return this._x;
		}
		
	}





	///////////////////////////////
	//
	// Human Player
	//
	///////////////////////////////
	class HumanPlayer extends Player {
		constructor ( portraitSrc ) {
			console.log("HumanPlayer constructor()");
			super( portraitSrc );
		}
		init () {
			super.init();
			for ( let i = 0; i < this.rack.slots.length; i++ ) {
				let slot = this.rack.slots[i];
				// Handle Clicking Slots
				let evt = isTouch ? 'touchend' : 'click';
				$(slot.el).on( evt, () => {
					Game.clickSlot( slot );
				})
			};
			// Handle clicking cards
			// Does this belong in Game object?  .startTurn, .humanPhase, .startGame?
			for ( let c = 0; c < this.deck.cards_ar.length; c++ ) {
				let card = this.deck.cards_ar[c];
				card.setSelectBehavior( Game.clickCard );
			}
		}
		assemble(){
			super.assemble();
			for ( let i = 0; i < this._elementFields.length; i++ ){
				let field = this._elementFields[i];
				Game.positionElement( field, 370+ 91*i, this._size - Game.getElementHeight( field ) ) ;
				$(field).css( "width", 88 );
			}
			Game.positionElement(this.hpField, this._size, this._size - Game.getElementHeight( this.hpField ) );
			Game.positionElement(this.nameField, this._size + Game.getElementWidth( this.hpField ) + 8, this._size - Game.getElementHeight( this.nameField ) );
		}
		set y ( value ) {
			if ( value != undefined ) {
				super.y = value;
				this.rack.y = this._y - ( this.rack.height - this.height ) - 50;
			}
		}
		get y () {
			return this._y;
		}
	}





	///////////////////////////////
	//
	// AI Player
	//
	///////////////////////////////
	class AIPlayer extends Player {
		constructor ( portraitSrc ) {
			console.log("AIPlayer constructor()");
			super( portraitSrc );
			// this.deck.removeEl();
		}
		assemble(){
			super.assemble();
			for ( let i = 0; i < this._elementFields.length; i++ ){
				let field = this._elementFields[i];
				Game.positionElement( field, 370+ 91*i, 0 ) ;
				$(field).css( "width", 88 );
			}
			Game.positionElement(this.hpField, this._size, 0 );
			Game.positionElement(this.nameField, this._size + Game.getElementWidth( this.hpField ) + 8, 0 );
		}
		set y ( value ) {
			if ( value != undefined ) {
				super.y = value;
				this.rack.y = this._y + 50;
			}
		}
		get y () {
			return this._y;
		}
	}









	///////////////////////////////
	//
	// 		RACK (row of cards) CLASS
	//
	///////////////////////////////
	class Rack extends GameElement {
		constructor ( player ) {
			console.log("Rack constructor()");
			let _myEl = document.createElement("div");
			super( _myEl );
			// console.log("rack _x: "+this._x+", _y: "+this._y);
			this._myEl = _myEl;
			$(this._myEl).addClass("card-rack");
			this.init();
			this.assemble();
			this._player = player;
		}

		init () {
			this._numSlots = 6;
			this._slots = [];
			for ( let i = 0; i < this._numSlots; i++ ) {
				let slot = new Slot( this, i );
				this._slots.push( slot );
				this._myEl.appendChild( slot.el );
				slot.x = i * cardWidth;
			}
		}

		assemble(){
			gameContainer.appendChild( this._myEl );
			this.width = 6*cardWidth;
			this.height = cardHeight;
		}

		putCardInSlot ( card, slotArg ) {

			// argument [slotArg] is instance of Slot or is an integer
			let slot = slotArg instanceof Slot ? slotArg :  this._slots[ slot ];

			if ( card instanceof Card && slot instanceof Slot ) {
				slot.card = card;
				card.owner = this.player;
				// card.x = this._x + slot.x;
				// card.y = this._y + slot.y;
			}
		}

		clearSlot ( slotArg ) {
			// argument [slotArg] is instance of Slot or is an integer
			let slot = slotArg instanceof Slot ? slotArg :  this._slots[ slot ];
			slot.clear();
		}

		getEmptySlots () {
			let emptySlots = this._slots.filter( slot => slot.card == undefined );
			return emptySlots;
		}

		get slots () {
			return this._slots;
		}
		get slotAvailable () { 
		// returns booelan
			for ( let s = 0; s < this._slots.length; s ++ ) {
				if ( this._slots[s].card == undefined ) {
					return true;
				}
			}
			return false;
		}
		get player () {
			return this._player;
		}
	}




	///////////////////////////////
	//
	// 		Slot (card holder) CLASS
	//
	///////////////////////////////
	class Slot extends GameElement {
		constructor ( rack, index ) {
			let _myEl = document.createElement("div");
			super( _myEl );
			this._myRack = rack;
			this._myEl = _myEl;
			$(this._myEl).addClass("card-slot");
			this._index = index;
			this.init();
			this.assemble();
		}
		init () {
			this._content = null;
		}
		assemble () {
			this.width = cardWidth;
			this.height = cardHeight;
		}
		clear () {
			if ( this.card != null ) {
				// delete the card
				// this.card.kill();
				this.card = null;
			}
		}
		get card () {
			return this._content;
		}
		set card ( card ) {
			if ( card instanceof Card || card == undefined ) {
				this._content = card;
				if ( card instanceof Card ) {
					card.slot = this;	
					// put card element inside this slot
					card.changeParent(this.el);
					card.x = 0;//this.x + this.rack.x;
					card.y = 0;//this.y + this.rack.y;
				}
				// animate card into this slot
				
			}
		}
		get index () {
			return this._index;
		}
		get rack () {
			return this._myRack;
		}
	}











	///////////////////////////////
	//
	// 		DECK CLASS ( Set of Cards belonging to a player )
	//
	///////////////////////////////
	/*
		Deck is 4x4 - 4 elements, 4 levels (cost) per element
	*/
	class Deck extends GameElement {
		constructor ( player ) {
			console.log("Deck constructor()");
			let _el = document.createElement("div");
			super(_el);
			gameContainer.appendChild(this.el);
			// $(this.el).addClass( "card-deck" );
			this._cards_ar = [];
			this.init();
			this._player = player;
		}

		init () {
			// Build deck of cards
			// col = element-index, row = power (cost-range)
			for( let col = 0; col < 4; col++ ) {
				for( let row = 0; row < 4; row++ ) {
					// pick a cost from range -> 1-3, 4-6, 7-9, 10-12
					let cost = row * 3 + Math.floor( Math.random() * 3 ) + 1;
					let card = Game.pickCard( col, cost );
					// $(card.el).detach();
					// $(this.el).append(card.el);
					card.changeParent(this.el);
					card.x = col * cardWidth;
					card.y = row * cardHeight;
					this._cards_ar.push(card);
				}
			}
		}

		removeEl () {
			for ( let c = 0; c < this._cards_ar.length; c++ ) {
				this._cards_ar[c].removeEl();
			}
			if ( this.el.parentElement ) {
				this.el.parentElement.removeChild( this.el );
			}
			
		}

		flipCards( immediate ) {
			// Flip Cards
			if ( immediate === true ) {
				for ( let c = 0; c < this._cards_ar.length; c++ ) {
					this._cards_ar[ c ].flip( true );
				}
			} else {
				let cardIndex = 0;
				let dur = 100;
				let flipInterval = setInterval(() => 
					{
						this._cards_ar[ cardIndex ].flip();
						cardIndex ++;
						if ( cardIndex >= this._cards_ar.length ) {
							clearInterval(flipInterval);
						}
					}
					, dur);		
			}
				
		}

		hilite () {
			console.log("Deck.hilite()");
			for (let c = 0; c < this._cards_ar.length; c++ ) {
				let card = this.cards_ar[c];
				card.hilite();
			}
		} 

		unhilite () {
			for (let c = 0; c < this._cards_ar.length; c++ ) {
				let card = this.cards_ar[c];
				card.unhilite();
			}
		}

		deselect () {
			for ( let c = 0; c < this._cards_ar.length; c++ ){
				this._cards_ar[c].deselect();
			}
		}

		lock () {
			for ( let c = 0; c < this._cards_ar.length; c++ ){
				this._cards_ar[c].lock();
			}
		}
		get player () {
			return this._player;
		}

		get cards_ar () {
			return this._cards_ar;
		}
		set x ( value ) {
			if ( value != undefined && typeof (value) == "number"){
				super.x = value;
				for ( let c = 0; c < this._cards_ar.length; c++ ) {
					let card = this._cards_ar[c];
					card.x = this._x + card.elementIndex * cardWidth;
				}
			}
		}
		get x () {
			return this._x;
		}
		set y ( value ) {
			if ( value != undefined && typeof (value) == "number"){
				super.y = value;
				for ( let c = 0; c < this._cards_ar.length; c++ ) {
					let card = this._cards_ar[c];
					card.y = this._y + Math.floor( card.cost / 3 ) * cardHeight;
				}
			}
		}
		get y () {
			return this._y;
		}
		
	}


		














	///////////////
	////////////////////////////
	///////////////////////////////////////////////////////
	//
	//
	//		v GAME object (singleton?) v
	//
	//
	///////////////////////////////////////////////////////
	////////////////////////////
	///////////////

	let Game = {};

	Game.turnNum = 0;
	Game.turnPhase = 0; // 0 = human, 1 = AI
	Game.turnPhasePortion = ""; // "start", "end"
	Game.activePlayer = null;
	Game.passivePlayer = null;
	Game.selectedCard = null;
	Game.gameOver = false;

	Game.initGame = function() {
		console.log("Game.initGame()");
		// Game.createTempCardSet();
		Game.buildSourceDeckFromData( cards_dataObj );
		// -----------------------------------------------
		// Make Players, Human and AI
		// -----------------------------------------------
		computerPlayer = new AIPlayer( "AI Character" );
		computerPlayer.x = 70;
		computerPlayer.y = 0;
		computerPlayer.setElement(0, 8);
		computerPlayer.setElement(1, 5);
		computerPlayer.setElement(2, 10);
		computerPlayer.setElement(3, 3);
		computerPlayer.deck.flipCards( true );
		// console.log("computerPlayer.deck: "+computerPlayer.deck);
		// computerPlayer.deck.removeEl();
		// TEMP for visualizing:
		// $(AICardGrid).detach();
		$(computerPlayer.deck.el).detach();
		$(AICardGrid).append($(computerPlayer.deck.el));
		// $(computerPlayer.deck.el).css("top",300);
		// $(computerPlayer.deck.el).css("border", "12px solid orange");

		
		// $(gameContainer).append($(AICardGrid));

		livePlayer = new HumanPlayer( "Player" );
		livePlayer.x =  70;
		livePlayer.y = 240;
		livePlayer.setElement(0, 5);
		livePlayer.setElement(1, 10);
		livePlayer.setElement(2, 3);
		livePlayer.setElement(3, 8);

		// Position Human player's cards
		$(livePlayer.deck.el).detach();
		$(playerCardGrid).append($(livePlayer.deck.el));
		
	}

	Game.startGame = function () {
		console.log("Game.startGame()");
		livePlayer.deck.flipCards();
		// wait is magic number, to wait for all the human player's cards to flip over before unlocking them
		let wait = setTimeout( Game.startTurn, 2500 );
		
	}

	/////////////////////////////////////////////////
	//
	//			GAME TURN PARTS
	//
	/////////////////////////////////////////////////
	Game.startTurn = function () {
		console.log("Game.startTurn()");
		if ( Game.gameOver ) return;
		Game.turnNum ++;
		console.log( "Turn "+Game.turnNum );
		console.log("---------------------------------");
		console.log("\r\n");
		
		$(turnCountField).html("Turn <br />"+Game.turnNum);
		Game.turnPhase = 0;
		Game.startPhase();
	}
	Game.startPhase = function () {
		console.log("Game.startPhase()");
		console.log("Game.turnPhase: "+Game.turnPhase);
		console.log("---------------------------------");
		if ( Game.gameOver ) return;
		Game.selectedCard = null;
		Game.activePlayer = Game.turnPhase === 0 ? livePlayer : computerPlayer;
		Game.passivePlayer = Game.activePlayer === livePlayer ? computerPlayer : livePlayer;
		
		// Add Element points (+1 default)
		Game.updatePlayerElementPoints();
		Game.unlockPlayableCards( Game.activePlayer );
		Game.turnPhasePortion = "start";
		if ( Game.turnPhase === 0 ) {
			Game.startHumanPhase();
		} else if ( Game.turnPhase === 1 ) {
			Game.startAIPhase();
		}
	}
	Game.startHumanPhase = function() {
		console.log("Game.startHumanPhase()");
		
	}
	Game.startAIPhase = function () {
		console.log("Game.startAIPhase()");
		
		AISelectCard ();		
	}
	Game.endPhase = function () {
		console.log("Game.endPhase()");
		if ( Game.gameOver ) return;
		// Handle non-attack effects for each card
		// ...
		// Damage host 
		// Damage enemy
		// Heal host
		// Increase host element power
		// Decrease host element power
		// Decrease enemy element power
		// Game.resolveAttacks();
		Game.turnPhasePortion = "end";
		// Check Cards Specials
		Game.turnPhase ++;

		if ( Game.turnPhase >= 2 ) {
			Game.endTurn();
		} else {
			Game.startPhase();
		}
		
	}
	// Game.nextPhase = function () {
		
	// 	Game.startPhase();
		
	// }
	Game.endTurn = function () {
		console.log("Game.endTurn()");
		console.log("=============================\n\r")
		Game.startTurn();
	}

	Game.endGame = function () {
		console.log("Game.endGame()");
		Game.gameOver = true;
		// Lock both decks
		Game.activePlayer.deck.lock();
		Game.passivePlayer.deck.lock();
		// Announce winner
		let winner, loser;
		if ( livePlayer.hp <= 0 ) {
			winner = computerPlayer;
			loser = livePlayer;
		} else if ( computerPlayer.hp <= 0 ) {
			winner = livePlayer;
			loser = computerPlayer;
		}
		alert ( winner.name+" has defeated "+loser.name+" in "+Game.turnNum+" turns!" );
	}

	Game.checkGameOver = function () {
		if ( livePlayer.hp <= 0 || computerPlayer.hp <= 0 ) {
			Game.endGame();
		}
	}


	


	/////////////////////////////////////////////////
	//
	//			GAME TURN ACTIONS
	//
	/////////////////////////////////////////////////

	Game.selectCard = function( whichCard ) {
		console.log("Game.selectCard()");
		Game.selectedCard = whichCard;
	}
	Game.clickCard = function () {
		console.log("Game.clickCard()");

		// First, deselect all the cards
		livePlayer.deck.deselect();

		// If it's Human Player's turn
		console.log("Game.activePlayer: "+Game.activePlayer);
		console.log("livePlayer: "+livePlayer);
		console.log("Game.activePlayer == livePlayer: "+(Game.activePlayer == livePlayer));
		if ( Game.activePlayer === livePlayer

		// ...and card isn't locked...
		&& !this.locked ){
			
			// If card is type "spell"
			if ( this.type == "spell" ) {
				// Do the spell
				Game.playSpellCard( this );
				this.hilite();
				let that = this;
				setTimeout( function(){
					that.unhilite();
					livePlayer.deck.lock();
					Game.resolveAttacks();
				}, 100 );
			} else if ( this.type == "creature" 
				// Else if card is type "creature"
			&& livePlayer.rack.slotAvailable ) {
				// ...and slot is available in Human rack...
				this.hilite();
				// select that card to be placed in next slot clicked
				Game.selectCard( this );
			
			}
		}
	}
	Game.clickSlot = function ( slot ) {
		console.log("Game.clickSlot()");
		/*
			Slot in a rack has been clicked / touched.  Decide what to do with that...
		*/
		// If it's HumanPlayer's turn,
		if ( Game.activePlayer != livePlayer )	return;
		
		// IF HumanPlayer has a card selected,

		if ( Game.selectedCard instanceof Card 
		// And the slot is empty
		&& slot.card == undefined ) {
			// must be creature because it is a selected card ( spells can't be selected )
			Game.playCreatureCard( Game.selectedCard, slot );

			// Deselect original card
			Game.selectedCard.deselect();

			livePlayer.deck.lock();

			// Game.endPhase();
			Game.resolveAttacks();
		}
	}
	
	
	Game.playSpellCard = function ( card ) {
		console.log("Game.playSpellCard()");
		Game.chargePlayerForCard( card );

		// Temp - just attack opponenet w/ card's attack value
		console.log("card.attack: "+card.attack);
		Game.passivePlayer.takeDamage( card.attack );
		Game.checkGameOver();

		// Game.resolveAttacks();

		// Does the spell operate automatically?

			// on the Active player?

			// and/or on the Passive player?

			// and/or on Active player card?

			// and/or on Passive player card?

		// Or does spell require clicking on a target card?

			// Owner's card?

			// Opponent's card?

	}

	Game.playCreatureCard = function ( card, slot ) {
		
		Game.chargePlayerForCard( card );

		let dupCard = Game.duplicateCard( card );
		dupCard.undim();

		Game.activePlayer.rack.putCardInSlot( dupCard, slot );
		
	}

	Game.chargePlayerForCard = function( card ) {
		// console.log("Game.chargePlayerForCard()");
		Game.activePlayer.subtractFromElement( card.elementIndex, card.cost );
	}
	Game.updatePlayerElementPoints = function () {
		// Default +1 to each element
		for ( let i = 0; i < Game.activePlayer.elementValues.length; i++ ) {
			Game.activePlayer.addToElement( i, 1 );	
		}
	}
	Game.resolveAttacks = function() {
		Game.arrangeRackDepths();
		let slotIndexes = [];
		for ( let s = 0; s < Game.activePlayer.rack.slots.length; s++ ) {
			// Check each slot for a card
			let card = Game.activePlayer.rack.slots[s].card;
			if ( card != undefined && card.turnPlayed < Game.turnNum ) {
				// Cards by default can't attack on the same turn that they are played
				slotIndexes.push( s );
			}
		}
		if ( slotIndexes.length > 0 ) {
			// If Player has any cards in rack...
			let si = 0;
			let attackWait = setInterval( function() {
				console.log("Game.resolveAttacks(), setInterval");
				// let curplayer = Game.activePlayer == livePlayer ? "Human" : "Computer";
				// console.log("Player: "+curplayer);
				// console.log("si vs slotIndexes.length:"+si+" ... "+slotIndexes.length);
				// execute card's attack
				Game.cardAttack( slotIndexes[ si ] );
				si++;
				
				if ( si >= slotIndexes.length || Game.gameOver ) {
					clearInterval( attackWait );
					let wait = setTimeout( Game.endPhase, 1000 );
				}
			}, 1000 );
		} else {
			let wait = setTimeout( Game.endPhase, 1000 );
		}
	}
	Game.cardAttack = function ( slotIndex ) {
		console.log("Game.cardAttack( "+slotIndex+" )");
		if ( Game.gameOver ) {
			return;
		}
		console.log("...executing Game.cardAttack()");
		let card = Game.activePlayer.rack.slots[ slotIndex ].card;
		let defenderCard = Game.passivePlayer.rack.slots[ slotIndex ].card;
		if ( card != undefined ) {
			// Animate card
			let dur = 0.5,
				ty;
			if ( Game.activePlayer === livePlayer ) {
				// Slide up
				ty = -30;
			}else {
				// Slide down
				ty = +30;
			}
			TweenMax.to( card.el, dur, {css:{y:"+="+ty}, yoyo:true, repeat:1, ease:Sine.easeInOut, onRepeat: complete});
			TweenMax.to( card.shadow, dur, {css:{y:"+="+ty}, yoyo:true, repeat:1, ease:Sine.easeInOut});
	
			function complete() {
				console.log("Tween Complete()");
				
				if ( defenderCard == undefined ) {
					// no card, attack goes through to passivePlayer
					Game.passivePlayer.takeDamage( card.attack );
				}else {
					// attack defender's card
					defenderCard.takeDamage( card.attack );
				}

				// Is a player defeated?
				Game.checkGameOver();
				
			}
			
		}
	}



	/////////////////////////////////////////////////
	//
	//			GAME UTILITY FUNCTIONS
	//
	/////////////////////////////////////////////////

	Game.arrangeRackDepths = function () {
		// Put attacking Player's rack above defender's
		let aSlots = Game.activePlayer.rack.slots;
		let pSlots = Game.passivePlayer.rack.slots;
		let length = aSlots.length;
		for ( let a = 0; a < length; a++ ) {
			if ( pSlots[a].card != undefined ) {
				pSlots[a].card.el.style.zIndex = 10+length+a;
				pSlots[a].card.shadow.style.zIndex = 10+a;
			}
			if ( aSlots[a].card != undefined ) {
				aSlots[a].card.el.style.zIndex = 10+length*3+a;
				aSlots[a].card.shadow.style.zIndex = 10+length*2+a;
			}
		}
		// Game.passivePlayer.rack.el.style.zIndex = "1";
		// Game.activePlayer.rack.el.style.zIndex = "2";
	}

	Game.duplicateCard = function ( card ) {
		// Duplicate that card
		let dupCard = new Card(
		card.elementIndex,
		card.attack,
		card.defense,
		card.hp,
		card.cost,
		card.img,
		card.title,
		card.type);
		// Place face up on top of original card
		dupCard.x = card.x;
		dupCard.y = card.y;
		dupCard.flip( true );
		
		return dupCard;
	}



	Game.positionElement = function( el, x, y ) {
		$(el).css({top: y, left: x});
	}
	Game.getElementHeight = function( el ) {
		return $(el).outerHeight();
	}
	Game.getElementWidth = function( el ) {
		return $(el).outerWidth();
	}
	Game.getElementPosition = function( el ) {
		let pos = $(el).position();
		return { x: pos.left, y: pos.top };
	}

	/////////////////////////////////////////////////
	//
	//			BUILD and manage GAME DECK (Master Deck)
	//
	/////////////////////////////////////////////////

	Game.cards_ar = [];

	/*
	{"name" : "fire", "cards" : [
		{ 
		"name" : "Goblin Berserker",
		"element" : "fire",
		"type" : "creature",
		"attack" : 4,
		"life" : 16,
		"cost" : 1,
		"specials" : [
			{
				"event" : "owner-turn-start",
				"target" : "neighbors",
				"effect" : "hp",
				"amount" : -2,
			}]
		}
	*/

	Game.buildSourceDeckFromData = function ( dataObj ) {
		for ( let e = 0; e < dataObj.elements.length; e++ ) {
			let element = dataObj.elements[e];
			for ( let c = 0; c < element.cards.length; c++ ) {
				let card = element.cards[c];
				let def = card.defense != undefined ? card.defense : 0;
				Game.cards_ar.push( 
					{ type : card.type, 
					elementIndex : e, 
					attack : card.attack, 
					defense : def, 
					cost : card.cost, 
					src : "images/sample-image.jpg", 
					name : card.name, 
					hp : card.life,
					specials : card.specials
					 }
				 );
			}
		}
	}
	// TEMP GENERATE ARTIFICIAL CARD TYPES:
	// ALL CARDS
	Game.createTempCardSet = function () {
		// All the cards, from which "Decks" are selected, using "Game.pickCard()"
		let names = ["supply", "downtime", "product", "incentive"];
		for ( let t = 0; t < names.length; t++ ) {
			for ( let i = 0; i < 12; i++ ) {
				let name = names[t]+" "+i;
				name = name.charAt(0).toUpperCase() + name.slice(1);
				type = Math.random() < 0.5 ? "creature" : "spell";
				let atk = type == "creature" ? i : i*2;
				Game.cards_ar.push( 
					{ type: type, elementIndex: t, attack: atk, defense: i, cost: i, src: "images/sample-image.jpg", name: name, hp: (i+2)*5 }
				 );
			}
		}
	}
	
	Game.makeCardByName = function ( name ) {
		console.log("makeCardByName( "+name+" )")
		let cards = Game.cards_ar.filter( card => card.name == name );
		let card = cards[0]; // There is only 1 card of each name
		/*
		 Also, cards should have (effects at end of owner's turn):

		 Owner Element modifiers: [w,x,y,z]
		 Opponent Element modifiers: [w,x,y,z]
		 Owner HP modifier: x
		 Opponent HP mofifier: x
		 Self (creature) HP modifier: x
		 Neighbors (creatures) HP modifiers: [x,y]
		 Siblings (creatures) HP modifier: x
		 */

		return new Card ( card.elementIndex, card.attack, card.defense, card.hp, card.cost, card.src, card.name, card.type );
	}

	Game.pickCard = function ( elementIndex, cost ) {
		
		//	Select from the full card set, Game.cards_ar, a card of specified element type and cost 
		
		function meetsCriteria ( card ) {
			return card.elementIndex == elementIndex && card.cost == cost;
		}
		// create array of all cards that match the criteria.
		elegibleCards_ar = Game.cards_ar.filter( meetsCriteria );
		// then randomly pick one.
		let index = Math.floor( Math.random()*(elegibleCards_ar.length-1) );
		console.log("index: "+index);
		if ( index == -1 ) {
			console.log( "tried to pickCard (elementIndex,cost): "+elementIndex+", "+cost);
		}
		if ( index != -1 ) {
			let name = elegibleCards_ar[ index ].name;
			return Game.makeCardByName( name );
		}
		
	}

	Game.GUIanimatePoints = function ( points, el ) {
		let pointsEl = document.createElement("span");
		let sign = points > 0 ? "positive" : "negative";		
		pointsEl.className = "points-field "+sign;
	}
	Game.unlockPlayableCards = function ( player ) {

		// Lock Cards in Deck that are not playable by player's elementValues

		let deck = player.deck.cards_ar;

		let elementValues = player.elementValues;

		// For each element, lock/unlock cards of that element which player can afford
		for ( let e = 0; e < elementValues.length; e++ ) {
			let elementIndex = e;
			let elementValue = elementValues[e];
			for ( let c = 0; c < deck.length; c++ ) {
				let card = deck[c];

				// If all Player Slots are filled, only Spell cards are eligible for unlocking
				if ( card.elementIndex === elementIndex ) {
					if ( card.cost > elementValue || ( !player.rack.slotAvailable && card.type === "creature" ) ) {
						card.lock();
					} else {
						card.unlock();
					}
				}
			}
		}
	}



	/////////////////////////////////////////////////
	//
	//			v Dev stuff for SPECIALS v
	//
	/////////////////////////////////////////////////


	Game.checkLiveCardsForSpecials = function () {
		// Look at every card in both racks
		let activeCards = Game.getAllCardsInRack( Game.activePlayer.rack );
		let passiveCards = Game.getAllCardsInRack( Game.passivePlayer.rack );
		let allCards = activeCards.concat(passiveCards);
		// For each of those cards, 
		for ( let a = 0; a < allCards.length; a++ ) {
			let activeCard = allCards[a];
			let specials = activeCard.specials;
			// Look through all its specials
			for ( let s = 0; s < specials.length; s++ ) {
				let special = specials[s];
				// If a special's event type is current
				console.log("event: "+special.event);
				console.log("player: "+activeCard.player);
				console.log(Game.isTimeForEvent( special.event, activeCard ));
				if ( Game.isTimeForEvent( special.event, activeCard ) ) {
					// Execute that special
					Game.executeSpecial( activeCard, special );
					console.log("Time For Special: "+activeCard.specials.event);
				}
			}
		}
	}

	Game.getCardSpecialsOfType = function ( card, eventType ) {
		let specials = [];
		for ( let s = 0; s < card.specials.length; s++ ) {
			let special = card.specials[ s ];
			// check if that special has correct event type
			if ( special.event === eventType ) {
				specials.push( special );
			}
		}
		return specials;
	}

	Game.checkDyingCardForSpecial = function ( card ) {
		// Call this when a card dies.
		// Does this card have a special of event "die"?
		let specials = Game.getCardSpecialsOfType( card, "die" );
		
		if ( specials.length > 0 ) {
			// execute those specials...
			for ( let s = 0; s < specials.length; s++ ) {
				let special = specials[ s ];
				// Execute that special
				Game.executeSpecial( card, special );
			}
		}
	}

	Game.executeSpecial = function ( card, special ) {
		// Execute that special
		let targets = Game.getTargetsOfSpecial( card, special );

		for ( let t = 0; t < targets.length; t++ ) {
			if ( special.effect = "hp" ) {
				// modify each hp
				if ( targets[t] == undefined || targets[t].hp == undefined ) {
					console.log("target...");
					console.log(targets[t]);
				}
				targets[t].hp += special.amount;
			} else if ( special.effect === "powers" ){
				// add to each power
				for ( let p = 0; p < special.amount.length; p++ ) {
					target.addToElement ( p, special.amount[p] )
				}
			}
		}
	}


	Game.getTargetsOfSpecial = function ( card, special ) {
		let targets = [];
		let owner = card.player;
		let opponent = owner === Game.activePlayer ? Game.passivePlayer : Game.activePlayer;
		// find target(s)
		console.log("special.target: "+special.target);
		switch ( special.target ) {
			case "owner":
			// Get Game.activePlayer
				targets.push(owner);
				break;
			case "opponent":
			// Get Game.passivePlayer
				targets.push(opponent);
				break;
			case "owner-creatures":
			// All cards_data in Owner's rack
			console.log("owner: "+owner);
				targets.push( Game.getAllCardsInRack( owner.rack, card ) );
				break;
			case "opponent-creatures":
			// All cards_data in Opponent's rack
				targets.push( Game.getAllCardsInRack( opponent.rack ) );
				break;
			case "neighbors":
			// Cards to left/right of this card
				targets.push( Game.getCardNeighbors( card ) );
				break;
			case "across":
			// Card in same slot index of opponent's rack
				let acrossCard = Game.getCardAcross( card );
				if ( acrossCard != undefined ) {
					targets.push( acrossCard );
				}
				break;
			case "self":
			// This card
				targets.push( card );
				break;
			default:
		}
		return targets;
	}

	Game.getAllCardsInRack = function( rack, excludeCard ) {
		let cards = [];
		for ( let s = 0; s < rack.slots.length; s++ ) {
			let card = rack.slots[s].card;
			// if ( card instanceof Card && card != excludedCard ) {
				cards.push( card );
			// }
		}
		return cards;
	}

	Game.getCardNeighbors = function ( card ) {
		let cards = [];
		// Get card's slot index
		let index = card.slot.index;
		if ( index > 0 ) {
			// Get slot to left
			let leftSlot = card.slot.rack.slots[ index -1 ];
			if ( leftSlot.card != undefined ) {
				cards.push( leftSlot.card );
			}
		}
		if ( index < card.slot.rack.slots.length -1 ) {
			// Check Slot to right
			let rightSlot = card.slot.rack.slots[ card.slot.index + 1];
			if ( rightSlot.card != undefined ) {
				cards.push( rightSlot.card );
			}
		}
		return cards;
	}

	Game.getCardAcross = function ( card ) {
		let index = card.slot.index;
		let opponent = card.owner == Game.activePlayer ? Game.passivePlayer : Game.activePlayer;
		return opponent.rack.slots[ index ].card;
	}

	Game.isTimeForEvent = function ( eventType, card ) {
		console.log("Game.isTimeForEvent( "+eventType+", "+card.name);
		// Check if it is time to execute a card's special of eventType
		let ownerTurn = card.player === Game.activePlayer;
		let startPortion = Game.turnPhasePortion === "start";
		switch ( eventType ) {
			case "summon":
				// If card's owner is activePlayer, turnphase is start, and card was played this turn
				if ( ownerTurn && startPortion && card.turnPlayed === Game.turnNum ) {
					return true;
				}
			case "owner-turn-start":
				// if card's owner is activePlayer, and turnPhasePortion is "start"
				if ( ownerTurn && startPortion ) {
					return true;
				}
			case "owner-turn-end":
				if ( ownerTurn && !startPortion ) {
					return true;
				}
			case "opponent-turn-start":
				if ( !ownerTurn && startPortion ) {
					return true;
				}
			case "opponent-turn-end":
				if ( !ownerTurn && !startPortion ) {
					return true;
				}
			default: 
				return false;
		}
	}


	//				^ End Game Object ^												//
	//  																			//
	//////////////////////////////////////////////////////////////////////////////////








	// =====================================================================================
	//
	//
	// 			v POINT OF ENTRY v
	//
	//
	// =====================================================================================

	Game.initGame();
	Game.activePlayer = computerPlayer;
	// fillAIRack();
	Game.startGame();
	





	// =====================================================================================
	//
	//
	// 			v TEMP SETUP STUFF v
	//
	//
	// =====================================================================================

	
	

	function AISelectCard () {
		console.log("AISelectCard()");
		// Select card from AI deck
		// Get Cards We can afford
		// Game.unlockPlayableCards( computerPlayer );
		let cards;
		if ( computerPlayer.rack.slotAvailable ) {
			cards = computerPlayer.deck.cards_ar.filter( card => !card.locked );
		} else {
			cards = computerPlayer.deck.cards_ar.filter( card => !card.locked && card.type == "spell" );
		}

		// Of those, randomly pick one
		// let card = cards[ Math.floor( Math.random()*cards.length ) ];
		// Pick the most expensive
		cards.sort( function(a,b) {
			return b.cost - a.cost;
		});
		let card = cards[0];
		console.log("card.cost: "+card.cost);

		// Display Selected card until Human player acknowledges (clicks)
		Game.selectCard( card );
		AIShowSelectedCard( card );
	}
	function AIShowSelectedCard () {
		console.log("AIShowSelectedCard()");
		let displayCard = Game.duplicateCard ( Game.selectedCard );
		displayCard.undim();
		// displayCard.el.style.transformOrigin = "top left";
		// displayCard.shadow.style.transformOrigin = "top left";
		// $(displayCard.el).css("transform","scale(2)");
		// $(displayCard.shadow).css("transform","scale(2)");
		let pos = $(AICardGrid).position();
		console.log("pos: "+pos.left+", "+pos.top);
		console.log("typeof pos.left: "+(typeof pos.left) );
		displayCard.x = 200;
		displayCard.y = 50;
		// displayCard.width = cardWidth*2;
		// displayCard.height = cardHeight*2;
		console.log("displayCard.x: "+displayCard.x);
		
		

		// When user clicks the card...
		let evt = isTouch ? 'touchend' : 'click';
		$(displayCard.el).on( evt, () => {
			displayCard.kill();
			AIPlayCard ();
			computerPlayer.deck.lock();
			// Game.endPhase();
			Game.resolveAttacks();
		} );
		
	}
	function AIPlayCard () {
		console.log("AIPlayCard()");
		let card = Game.selectedCard;
		// If creature, 
		if ( card.type == "creature" ) {
			// pick a slot
			let slots_ar = computerPlayer.rack.getEmptySlots();
			let slot = slots_ar[ Math.floor( Math.random()*slots_ar.length ) ];
			// Put creature in slot
			Game.playCreatureCard( card, slot );
		} else if ( card.type == "spell" ) {

			// Or, if spell,

			// Cast it...
			Game.playSpellCard( card );
		}

		

		
	}

	function fillAIRack () {
		for ( let s = 0; s < 6; s++ ) {
			let slot = computerPlayer.rack.slots[s];

			// select creature to play
			let card = AIPickCreatureToPlay();

			// play card
			Game.playCreatureCard( card, slot );
		}
	}
	function AIPickCreatureToPlay(){
		
		// console.log("computerPlayer.deck: ");
		// console.log(computerPlayer.deck);
		let cards = computerPlayer.deck.cards_ar.filter( card => !card.locked && card.type == "creature" );
		let index = Math.floor( cards.length * Math.random() );
		let creatureCard = cards[index];
		return creatureCard;
	}

/*
Game.checkCreatureEvents = function( turnPhase ) {

			let ownerCreatures = [],
				opponentCreatures = [];
			// For each ActivePlayer's creature
			for ( let s = 0; s < Game.activePlayer.rack.slots.length; s++ ) {
				let slot = Game.activePlayer.rack.slots[s];
				if ( slot.card != undefined ) {
					ownerCreatures.push( slot.card );
				}
			}
			// For each PassivePlayer's creature
			for ( let s = 0; s < Game.passivePlayer.rack.slots.length; s++ ) {
				let slot = Game.passivePlayer.rack.slots[s];
				if ( slot.card != undefined ) {
					opponentCreatures.push( slot.card );
				}
			}

			let card = slot.card

			// Check card for special events
			if ( card.special != undefined && card.special.event == turnPhase ) {
				if ( card.damage > 0 ) {
					switch (card.special.target) {
						case "owner":
							card.owner.takeDamage( card.special.damage );
							break;
						case "owner-creatures-all":
							// Get card's slot index
							let index = card.slot.index;
							if ( index > 0 ) {
								// Get slot to left
								let leftSlot = card.slot.rack.slots[ index -1 ];
								if ( leftSlot.card != undefined ) {
									leftSlot.card.takeDamage( card.special.damage );
								}
							}
							if ( index < card.slot.rack.slots.length -1 ) {
								// Check Slot to right
								let rightSlot = card.slot.rack.slots[ card.slot.index + 1];
								if ( rightSlot.card != undefined ) {
									rightSlot.card.takeDamage( card.special.damage );
								}
							}
							
							break;
						case "owner-creatures-neighbors":

							break;
						case "opponent":

							break;
						case "opponent-creatures-all":

							break;
						case "opponent-creature-across":

							break;
						case "creature-self":

						default:


					}
				}
			}
		}
		*/
			/*
		SPECIAL
			EVENTS
				"summon"
				"die"
				"owner-turn-start"
				"owner-turn-end"
				"opponent-turn-start"
				"opponent-turn-end"
			ACTIONS
				"heal"
				"damage"
				"element-powers"
			TARGET
				"owner"
				"owner-creatures-all"
				"owner-creatures-neighbors"
				"opponent"
				"opponent-creatures-all"
				"opponent-creature-across"
				"creature-self"
*/

	/*
	=====================================================
	//
	//				UTILITY FUNCTIONS
	//
	=====================================================
	*/
	function arrayDeDuplicate(array) {
		var a = array.concat();
		for(var i=0; i<a.length; ++i) {
			for(var j=i+1; j<a.length; ++j) {
				if(a[i] === a[j])
					a.splice(j--, 1);
			}
		}
		return a;
	}
	





	// End Game namespace
})(this);
</script>
</body>
</html>